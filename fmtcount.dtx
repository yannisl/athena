%\iffalse
% fmtcount.dtx generated using makedtx version 0.94b (c) Nicola Talbot
% Command line args:
%   -macrocode ".*\.tex"
%   -macrocode "fmtcount.perl"
%   -setambles "fmtcount.perl=>\nopreamble\nopostamble"
%   -comment "fmtcount.perl"
%   -src "(.+)\.(sty)=>\1.\2"
%   -src "(.+)\.(def)=>\1.\2"
%   -src "(fmtcount\.perl)=>\1"
%   -src "(fc-.+\.tex\Z)=>\1"
%   -doc "fmtcount-manual.tex"
%   -author "Nicola Talbot"
%   -dir "source"
%   fmtcount
% Created on 2009/10/2 18:35
%\fi
%\iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
%\fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2009 Nicola Talbot, all rights reserved.
% \fi
% \iffalse
%<*driver>
\documentclass{ltxdoc}

\usepackage{color}
\usepackage[colorlinks,
            bookmarks,
            bookmarksopen,
            pdfauthor={Nicola L.C. Talbot},
            pdftitle={fmtcount.sty: Displaying the Values of LaTeX Counters},
            pdfkeywords={LaTeX,counter}]{hyperref}

\definecolor{defbackground}{rgb}{1,1,0.75}
\newsavebox\defsbox
\newlength\defwidth
\newenvironment{definition}{%
\setlength{\fboxsep}{4pt}\setlength{\fboxrule}{1.25pt}%
\begin{lrbox}{\defsbox}%
\setlength\defwidth\linewidth
\addtolength\defwidth{-2\fboxrule}%
\addtolength\defwidth{-2\fboxsep}%
\begin{minipage}{\defwidth}\flushleft
}{%
\end{minipage}
\end{lrbox}%
\vskip10pt
\noindent
\fcolorbox{black}{defbackground}{\usebox\defsbox}%
\vskip10pt
}


\newcommand{\sty}[1]{\textsf{#1}}\newcommand{\cls}[1]{\textsf{#1}}
\CheckSum{9371}
%\OnlyDescription

\begin{document}
\DocInput{fmtcount.dtx}
\end{document}
%</driver>
%\fi
%\RecordChanges
%
% \title{fmtcount.sty v1.31: Displaying the Values of 
%\LaTeX\ Counters}
% \author{Nicola L.C. Talbot\\[10pt]
% School of Computing Sciences\\
% University of East Anglia\\
% Norwich.  NR4 7TJ.\\
% United Kingdom.\\
% \url{http://theoval.cmp.uea.ac.uk/~nlct/}}
% \date{2nd October 2009}
% \maketitle
% \tableofcontents
% \section{Introduction}
%The \sty{fmtcount} package provides commands to display
%the values of \LaTeX\ counters in a variety of formats. It also
%provides equivalent commands for actual numbers rather than 
%counter names. Limited multilingual support is available. 
%Currently, there is only support for English, French (including
%Belgian and Swiss variations), Spanish, Portuguese, German and 
%Italian.
%
%\section{Installation}
%
%This package is distributed with the files \texttt{fmtcount.dtx}
%and \texttt{fmtcount.ins}.  To extract the code do:
%\begin{verbatim}
%latex fmtcount.ins
%\end{verbatim}
%This will create the files \texttt{fmtcount.sty} and 
%\texttt{fmtcount.perl}, along with several \texttt{.def} files.
%Place \texttt{fmtcount.sty} and the \texttt{.def} files somewhere
%where \LaTeX\ will find them (e.g.\ 
%\texttt{texmf/tex/latex/fmtcount/}) and place \texttt{fmtcount.perl} 
%somewhere where \LaTeX2HTML
%will find it (e.g.\ \texttt{latex2html/styles}). Remember to refresh
%the \TeX\ database (using \texttt{texhash} or \texttt{mktexlsr} 
%under Linux, for
%other operating systems check the manual.)
%
%\section{Available Commands}
%
%The commands can be divided into two categories: those that
%take the name of a counter as the argument, and those
%that take a number as the argument.
%
% \DescribeMacro{\ordinal}
%\begin{definition}
%\cs{ordinal}\marg{counter}\oarg{gender}
%\end{definition}
% This will print the value of a \LaTeX\ counter \meta{counter} as an 
%ordinal, where the macro
%\DescribeMacro{\fmtord}
%\begin{definition}
%\cs{fmtord}\marg{text}
%\end{definition}
%is used to format the st, nd, rd, th bit.  By default the ordinal is
%formatted as a superscript, if the package option \texttt{level} is
%used, it is level with the text.  For example, if the current section
%is 3, then \verb"\ordinal{section}" will produce the output:
%3\textsuperscript{rd}. Note that the optional argument \meta{gender} 
%occurs \emph{at the end}. This argument may only take one of
%the following values: \texttt{m} (masculine), \texttt{f}
%(feminine) or \texttt{n} (neuter.) If \meta{gender} is omitted, 
%or if the given gender has no meaning in the current language, 
%\texttt{m} is assumed.
%
%\textbf{Notes:} 
%\begin{enumerate}
%\item the \cls{memoir} class also defines a command called
%\cs{ordinal} which takes a number as an argument instead of a
%counter. In order to overcome this incompatiblity, if you want
%to use the \sty{fmtcount} package with the \cls{memoir} class 
%you should use \DescribeMacro{\FCordinal}\cs{FCordinal} to access 
%\sty{fmtcount}'s version of \cs{ordinal}, and use 
%\cs{ordinal} to use \cls{memoir}'s version of that command.
%
%\item As with all commands which have an optional argument as the
%last argument, if the optional argument is omitted, any spaces
%following the final argument will be ignored. Whereas, if the
%optional argument is present, any spaces following the optional
%argument won't be ignored. so \verb"\ordinal{section} !"
%will produce: 3\textsuperscript{rd}! whereas
% \verb"\ordinal{section}[m] !" will produce:
%3\textsuperscript{rd} !
%\end{enumerate}
%
%\DescribeMacro{\ordinalnum}
%\begin{definition}
%\cs{ordinalnum}\marg{n}\oarg{gender}
%\end{definition}
%This is like \cs{ordinal} but takes an actual number rather than a 
%counter as the argument. For example: \verb"\ordinalnum{3}" will
%produce: 3\textsuperscript{rd}.
%
% \DescribeMacro{\numberstring}
%\begin{definition}
%\cs{numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as text.  E.g.\
%\verb"\numberstring{section}" will produce: three. The optional
%argument is the same as that for \cs{ordinal}.
%
% \DescribeMacro{\Numberstring}
%\begin{definition}
%\cs{Numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but with initial letters in
%uppercase.  For example, \verb"\Numberstring{section}" will produce:
%Three.
%
%\DescribeMacro{\NUMBERstring}
%\begin{definition}
%\cs{NUMBERstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but converts the string to
%upper case. Note that
%\verb"\MakeUppercase{\NUMBERstring{"\meta{counter}\verb'}}' doesn't
%work, due to the way that \cs{MakeUppercase} expands its
%argument\footnote{See all the various postings to
%\texttt{comp.text.tex} about \cs{MakeUppercase}}.
%
%\DescribeMacro{\numberstringnum}
%\begin{definition}
%\cs{numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\DescribeMacro{\Numberstringnum}
%\begin{definition}
%\cs{Numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\DescribeMacro{\NUMBERstringnum}
%\begin{definition}
%\cs{NUMBERstringnum}\marg{n}\oarg{gender}
%\end{definition}
%Theses macros  work like 
%\cs{numberstring}, \cs{Numberstring} and \cs{NUMBERstring}, 
%respectively, but take an actual number
%rather than a counter as the argument. For example:
%\verb'\Numberstringnum{105}' will produce: One Hundred and Five.
%
% \DescribeMacro{\ordinalstring}
%\begin{definition}
%\cs{ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as a textual ordinal.
%E.g.\ \verb"\ordinalstring{section}" will produce: third. The
%optional argument is the same as that for \cs{ordinal}.
%
% \DescribeMacro{\Ordinalstring}
%\begin{definition}
%\cs{Ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with initial letters in
%uppercase.  For example, \verb"\Ordinalstring{section}" will produce:
%Third.
%
%\DescribeMacro{\ORDINALstring}
%\begin{definition}
%\cs{ORDINALstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with all words in upper
%case (see previous note about \cs{MakeUppercase}).
%
%\DescribeMacro{\ordinalstringnum}
%\begin{definition}
%\cs{ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\DescribeMacro{\Ordinalstringnum}
%\begin{definition}
%\cs{Ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\DescribeMacro{\ORDINALstringnum}
%\begin{definition}
%\cs{ORDINALstringnum}\marg{n}\oarg{gender}
%\end{definition}
%These macros work like \cs{ordinalstring}, \cs{Ordinalstring} and
%\cs{ORDINALstring}, respectively, but take an actual number rather
%than a counter as the argument. For example,
%\verb"\ordinalstringnum{3}" will produce: third.
%
%\changes{v.1.09}{21 Apr 2007}{store facility added}
%As from version 1.09, textual representations can be stored for
%later use. This overcomes the problems encountered when you
%attempt to use one of the above commands in \cs{edef}.
%
%Each of the following commands takes a label as the first argument,
%the other arguments are as the analogous commands above. These
%commands do not display anything, but store the textual 
%representation. This can later be retrieved using
%\DescribeMacro{\FMCuse}
%\begin{definition}
%\cs{FMCuse}\marg{label}
%\end{definition}
%Note: with \cs{storeordinal} and \cs{storeordinalnum}, the 
%only bit that doesn't get expanded is \cs{fmtord}. So, for 
%example, \verb"\storeordinalnum{mylabel}{3}" will be stored as
%\verb"3\relax \fmtord{rd}".
%
%\DescribeMacro{\storeordinal}
%\begin{definition}
%\cs{storeordinal}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeordinalstring}
%\begin{definition}
%\cs{storeordinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeOrdinalstring}
%\begin{definition}
%\cs{storeOrdinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\par
%\DescribeMacro{\storeORDINALstring}
%\begin{definition}
%\cs{storeORDINALstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storenumberstring}
%\begin{definition}
%\cs{storenumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeNumberstring}
%\begin{definition}
%\cs{storeNumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeNUMBERstring}
%\begin{definition}
%\cs{storeNUMBERstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeordinalnum}
%\begin{definition}
%\cs{storeordinalnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeordinalstringnum}
%\begin{definition}
%\cs{storeordinalstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeOrdinalstringnum}
%\begin{definition}
%\cs{storeOrdinalstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeORDINALstringnum}
%\begin{definition}
%\cs{storeORDINALstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storenumberstringnum}
%\begin{definition}
%\cs{storenumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeNumberstringnum}
%\begin{definition}
%\cs{storeNumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%\DescribeMacro{\storeNUMBERstringnum}
%\begin{definition}
%\cs{storeNUMBERstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
% \DescribeMacro{\binary}
%\changes{v2.4}{25 Sept 2004}{'binary added}
%\begin{definition}
%\cs{binary}\marg{counter}
%\end{definition}
%This will print the 
%value of \meta{counter} as a binary number.  
%E.g.\ \verb"\binary{section}" will produce: 11.  The declaration 
%\DescribeMacro{\padzeroes}
%\begin{definition}
%\cs{padzeroes}\oarg{n}
%\end{definition}\noindent
%will ensure numbers are written to \meta{n} digits, padding with 
%zeroes if necessary.  E.g.\ \verb"\padzeroes[8]\binary{section}" 
%will produce: 00000011.  The default value for \meta{n} is 17.
%
%\DescribeMacro{\binarynum}
%\begin{definition}
%\cs{binary}\marg{n}
%\end{definition}
%This is like \cs{binary} but takes an actual number rather than a
%counter as the argument. For example: \verb"\binarynum{5}" will
%produce: 101.
%
%\DescribeMacro{\octal}
%\changes{v2.4}{25 Sept 2004}{'octal added}
%\begin{definition}
%\cs{octal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as an octal number.  For
%example, if you have a counter called, say \texttt{mycounter}, and
%you set the value to 125, then \verb"\octal{mycounter}" will produce:
%177.  Again, the number will be padded with zeroes if necessary,
%depending on whether \cs{padzeroes} has been used.
%
%\DescribeMacro{\octalnum}
%\begin{definition}
%\cs{octalnum}\marg{n}
%\end{definition}
%This is like \cs{octal} but takes an actual number rather than a
%counter as the argument. For example: \verb"\octalnum{125}" will
%produce: 177.
%
% \DescribeMacro{\hexadecimal}
%\changes{v2.4}{25 Sept 2004}{'hexadecimal added}
%\begin{definition}
%\cs{hexadecimal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as a hexadecimal number.
%Going back to the counter used in the previous example,
%\verb"\hexadecimal{mycounter}" will produce: 7d. Again, the number
%will be padded with zeroes if necessary, depending on whether
%\cs{padzeroes} has been used.
%
%\DescribeMacro{\Hexadecimal}
%\begin{definition}
%\cs{Hexadecimal}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\Hexadecimal{mycounter}" will produce: 7D.
%
%\DescribeMacro{\hexadecimalnum}
%\begin{definition}
%\cs{hexadecimalnum}\marg{n}
%\end{definition}
%\DescribeMacro{\Hexadecimalnum}
%\begin{definition}
%\cs{Hexadecimalnum}\marg{n}
%\end{definition}
%These are like \cs{hexadecimal} and \cs{Hexadecimal}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\hexadecimalnum{125}" will
%produce: 7d, and \verb"\Hexadecimalnum{125}" will 
%produce: 7D.
%
%\DescribeMacro{\decimal}
%\changes{v2.41}{22 Oct 2004}{'decimal added}
%\begin{definition}
%\cs{decimal}\marg{counter}
%\end{definition}
%This is similar to \cs{arabic} but the number can be padded with
%zeroes depending on whether \cs{padzeroes} has been used.  For
%example: \verb"\padzeroes[8]\decimal{section}" will produce:
%00000005.
%
%\DescribeMacro{\decimalnum}
%\begin{definition}
%\cs{decimalnum}\marg{n}
%\end{definition}
%This is like \cs{decimal} but takes an actual number rather than a
%counter as the argument. For example:
%\verb"\padzeroes[8]\decimalnum{5}" will produce: 00000005.
%
% \DescribeMacro{\aaalph}
%\changes{v2.4}{25 Sept 2004}{'aaalph added}
%\begin{definition}
%\cs{aaalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa bb
%\ldots\ zz etc.  For example, \verb"\aaalpha{mycounter}" will
%produce: uuuuu if \texttt{mycounter} is set to 125.
%
%\DescribeMacro{\AAAlph}
%\begin{definition}
%\cs{AAAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\AAAlph{mycounter}" will produce: UUUUU.
%
%\DescribeMacro{\aaalphnum}
%\begin{definition}
%\cs{aaalphnum}\marg{n}
%\end{definition}
%\DescribeMacro{\AAAlphnum}
%\begin{definition}
%\cs{AAAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{aaalph} and \cs{AAAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\aaalphnum{125}" will
%produce: uuuuu, and \verb"\AAAlphnum{125}" will 
%produce: UUUUU.
%
% \DescribeMacro{\abalph}
%\changes{v2.4}{25 Sept 2004}{'abalph added}
%\begin{definition}
%\cs{abalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa ab
%\ldots\ az etc.  For example, \verb"\abalpha{mycounter}" will
%produce: du if \texttt{mycounter} is set to 125.
%
% \DescribeMacro{\ABAlph}
%\begin{definition}
%\cs{ABAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\ABAlph{mycounter}" will produce: DU.
%
%\DescribeMacro{\abalphnum}
%\begin{definition}
%\cs{abalphnum}\marg{n}
%\end{definition}
%\DescribeMacro{\ABAlphnum}
%\begin{definition}
%\cs{ABAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{abalph} and \cs{ABAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\abalphnum{125}" will
%produce: du, and \verb"\ABAlphnum{125}" will 
%produce: DU.
%
%\section{Package Options}
%
%The following options can be passed to this package:
%
%\begin{tabular}{ll}
% \texttt{raise}    & make ordinal st,nd,rd,th appear as superscript\\
% \texttt{level}    & make ordinal st,nd,rd,th appear level with rest of 
%text
%\end{tabular}
%
%\noindent These can also be set using the command:
%
%\DescribeMacro{\fmtcountsetoptions}
%\begin{definition}
%\cs{fmtcountsetoptions}\verb"{fmtord="\meta{type}\verb'}'
%\end{definition}
%\noindent where \meta{type} is either \texttt{level} or 
%\texttt{raise}.
%
%\section{Multilingual Support}
%
%Version 1.02 of the \sty{fmtcount} package now has
%limited multilingual support.  The following languages are
%implemented: English, Spanish, Portuguese, French, French (Swiss)
%and French (Belgian). German support was added in version 
%1.1.\footnote{Thanks to K. H. Fricke for supplying the information.}
%Italian support was added in version 1.31.\footnote{Thanks to
%Edoardo Pasca for supplying the information.}
%
%The package checks to see if the command \cs{l@}\meta{language} is
%defined\footnote{this will be true if you have loaded \sty{babel}},
%and will load the code for those languages.  The commands
%\cs{ordinal}, \cs{ordinalstring} and \cs{numberstring} (and their
%variants) will then be formatted in the currently selected language.
%
%If the French language is selected, the French (France) version
%will be used by default (e.g.\ soxiante-dix for 70).  To
%select the Swiss or Belgian variants (e.g.\ septente for 70) use:
%\verb"\fmtcountsetoptions{french="\meta{dialect}\verb'}'
%where \meta{dialect} is either \texttt{swiss} or \texttt{belgian}.
%You can also use this command to change the action of 
%\cs{ordinal}.
%\verb"\fmtcountsetoptions{abbrv=true}" to produce ordinals
%of the form 2\textsuperscript{e} or
%\verb"\fmtcountsetoptions{abbrv=false}" to produce ordinals
%of the form 2\textsuperscript{eme} (default).
%
%The \texttt{french} and \texttt{abbrv} settings only have an
%effect if the French language has been defined.
%
%The male gender for all languages is used by default, however the
%feminine or neuter forms can be obtained by passing \texttt{f} or
%\texttt{n} as an optional argument to \cs{ordinal},
%\cs{ordinalnum} etc.  For example:
%\verb"\numberstring{section}[f]". Note that the optional argument
%comes \emph{after} the compulsory argument.  If a gender is
%not defined in a given language, the masculine version will
%be used instead.
%
%Let me know if you find any spelling mistakes (has been known
%to happen in English, let alone other languages with which I'm not so
%familiar.) If you want to add support for another language,
%you will need to let me know how to form the numbers and ordinals 
%from~0 to~99999 in that language for each gender.
%
%\section{Configuration File \texttt{fmtcount.cfg}}
%
%You can save your preferred default settings to a file called
%\texttt{fmtcount.cfg}, and place it on the \TeX\ path.  These
%settings will then be loaded by the \sty{fmtcount}
%package.
%
%Note that if you are using the \sty{datetime} package,
%the \texttt{datetime.cfg} configuration file will override
%the \texttt{fmtcount.cfg} configuration file.
%For example, if \texttt{datetime.cfg} has the line:
%\begin{verbatim}
%\renewcommand{\fmtord}[1]{\textsuperscript{\underline{#1}}}
%\end{verbatim}
%and if \texttt{fmtcount.cfg} has the line:
%\begin{verbatim}
%\fmtcountsetoptions{fmtord=level}
%\end{verbatim}
%then the former definition of \cs{fmtord} will take
%precedence.
%
%\section{LaTeX2HTML style}
%
%The \LaTeX2HTML\ style file \texttt{fmtcount.perl} is provided.
%The following limitations apply:
%
%\begin{itemize}
%\item \cs{padzeroes} only has an effect in the preamble.
%
%\item The configuration file 
%\texttt{fmtcount.cfg} is currently ignored. (This is because
%I can't work out the correct code to do this.  If you
%know how to do this, please let me know.)  You can however
%do:
%\begin{verbatim}
%\usepackage{fmtcount}
%\html{\input{fmtcount.cfg}}
%\end{verbatim}
%This, I agree, is an unpleasant cludge.
%
%\end{itemize}
%
%\section{Acknowledgements}
%
%I would like to thank my mother for the French and Portuguese
%support and my Spanish dictionary for the Spanish support.
%Thank you to K. H. Fricke for providing me with the German
%translations and to Edoardo Pasca for providing me with the
%Italian translations.
%
%\section{Troubleshooting}
%
%There is a FAQ available at: 
%\url{http://theoval.cmp.uea.ac.uk/~nlct/latex/packages/faq/}.
%
%
%
%\StopEventually{}
%\section{The Code}
%\iffalse
%    \begin{macrocode}
%<*fmtcount.sty>
%    \end{macrocode}
%\fi
%\subsection{fmtcount.sty}
% This section deals with the code for |fmtcount.sty|
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fmtcount}[2009/10/02 v1.31]
\RequirePackage{ifthen}
\RequirePackage{keyval}
%    \end{macrocode}
% \changes{1.3}{2007/7/19}{no
%longer using xspace package}
%\changes{1.31}{2009/10/02}{amsgen now loaded (\cs{new@ifnextchar}
% needed)}
% Need to use \cs{new@ifnextchar} instead of \cs{@ifnextchar} in
% commands that have a final optional argument (such as \cs{gls})
% so require \sty{amsgen}.
%    \begin{macrocode}
\RequirePackage{amsgen}
%    \end{macrocode}
% These commands need to be defined before the
% configuration file is loaded.
%
% Define the macro to format the |st|, |nd|, |rd| or |th| of an 
% ordinal.
%\begin{macro}{\fmtord}
%    \begin{macrocode}
\providecommand*{\fmtord}[1]{\textsuperscript{#1}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\padzeroes}
%\begin{definition}
%\cs{padzeroes}\oarg{n}
%\end{definition}
% Specifies how many digits should be displayed for commands such as
% \cs{decimal} and \cs{binary}.
%    \begin{macrocode}
\newcount\c@padzeroesN
\c@padzeroesN=1\relax
\providecommand*{\padzeroes}[1][17]{\c@padzeroesN=#1}
%    \end{macrocode}
%\end{macro}
% Load appropriate language definition files:
%\changes{v1.1}{14 June 2007}{added check for UKenglish,
% british and USenglish babel settings}
%    \begin{macrocode}
\@ifundefined{l@english}{}{\input{fc-english.def}}
\@ifundefined{l@UKenglish}{}{\input{fc-UKenglish.def}}
\@ifundefined{l@british}{}{\input{fc-british.def}}
\@ifundefined{l@USenglish}{}{\input{fc-USenglish.def}}
\@ifundefined{l@spanish}{}{\input{fc-spanish.def}}
\@ifundefined{l@portuges}{}{\input{fc-portuges.def}}
\@ifundefined{l@french}{}{\input{fc-french.def}}
\@ifundefined{l@german}{%
\@ifundefined{l@ngerman}{}{\input{fc-german.def}}}{%
\input{fc-german.def}}
\@ifundefined{l@italian}{}{\input{fc-italian.def}}
%    \end{macrocode}
%\begin{macro}{\fmtcount@french}
% Define keys for use with |\fmtcountsetoptions|.
% Key to switch French dialects (Does babel store
%this kind of information?)
%    \begin{macrocode}
\def\fmtcount@french{france}
\define@key{fmtcount}{french}[france]{%
\@ifundefined{datefrench}{%
\PackageError{fmtcount}{Language `french' not defined}{You need
to load babel before loading fmtcount}}{
\ifthenelse{\equal{#1}{france}
         \or\equal{#1}{swiss}
         \or\equal{#1}{belgian}}{%
         \def\fmtcount@french{#1}}{%
\PackageError{fmtcount}{Invalid value `#1' to french key}
{Option `french' can only take the values `france', 
`belgian' or `swiss'}}
}}
%    \end{macrocode}
%\end{macro}
% Key to determine how to display the ordinal
%    \begin{macrocode}
\define@key{fmtcount}{fmtord}{%
\ifthenelse{\equal{#1}{level}
          \or\equal{#1}{raise}
          \or\equal{#1}{user}}{
          \def\fmtcount@fmtord{#1}}{%
\PackageError{fmtcount}{Invalid value `#1' to fmtord key}
{Option `fmtord' can only take the values `level', `raise' 
or `user'}}}
%    \end{macrocode}
%\begin{macro}{\iffmtord@abbrv}
% Key to determine whether the ordinal should be abbreviated
% (language dependent, currently only affects French ordinals.)
%    \begin{macrocode}
\newif\iffmtord@abbrv
\fmtord@abbrvfalse
\define@key{fmtcount}{abbrv}[true]{%
\ifthenelse{\equal{#1}{true}\or\equal{#1}{false}}{
          \csname fmtord@abbrv#1\endcsname}{%
\PackageError{fmtcount}{Invalid value `#1' to fmtord key}
{Option `fmtord' can only take the values `true' or
`false'}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\fmtcountsetoptions}
% Define command to set options.
%    \begin{macrocode}
\newcommand*{\fmtcountsetoptions}[1]{%
\def\fmtcount@fmtord{}%
\setkeys{fmtcount}{#1}%
\@ifundefined{datefrench}{}{%
\edef\@ordinalstringMfrench{\noexpand
\csname @ordinalstringMfrench\fmtcount@french\noexpand\endcsname}%
\edef\@ordinalstringFfrench{\noexpand
\csname @ordinalstringFfrench\fmtcount@french\noexpand\endcsname}%
\edef\@OrdinalstringMfrench{\noexpand
\csname @OrdinalstringMfrench\fmtcount@french\noexpand\endcsname}%
\edef\@OrdinalstringFfrench{\noexpand
\csname @OrdinalstringFfrench\fmtcount@french\noexpand\endcsname}%
\edef\@numberstringMfrench{\noexpand
\csname @numberstringMfrench\fmtcount@french\noexpand\endcsname}%
\edef\@numberstringFfrench{\noexpand
\csname @numberstringFfrench\fmtcount@french\noexpand\endcsname}%
\edef\@NumberstringMfrench{\noexpand
\csname @NumberstringMfrench\fmtcount@french\noexpand\endcsname}%
\edef\@NumberstringFfrench{\noexpand
\csname @NumberstringFfrench\fmtcount@french\noexpand\endcsname}%
}%
%
\ifthenelse{\equal{\fmtcount@fmtord}{level}}{%
\renewcommand{\fmtord}[1]{##1}}{%
\ifthenelse{\equal{\fmtcount@fmtord}{raise}}{%
\renewcommand{\fmtord}[1]{\textsuperscript{##1}}}{%
}}
}
%    \end{macrocode}
%\end{macro}
% Load confguration file if it exists.  This needs to be done
% before the package options, to allow the user to override
% the settings in the configuration file.
%    \begin{macrocode}
\InputIfFileExists{fmtcount.cfg}{%
\typeout{Using configuration file fmtcount.cfg}}{%
\typeout{No configuration file fmtcount.cfg found.}}
%    \end{macrocode}
%Declare options
%    \begin{macrocode}
\DeclareOption{level}{\def\fmtcount@fmtord{level}%
\def\fmtord#1{#1}}
\DeclareOption{raise}{\def\fmtcount@fmtord{raise}%
\def\fmtord#1{\textsuperscript{#1}}}
%    \end{macrocode}
% Process package options
%    \begin{macrocode}
\ProcessOptions
%    \end{macrocode}
%\begin{macro}{\@modulo}
%\begin{definition}
%\cs{@modulo}\marg{count reg}\marg{n}
%\end{definition}
% Sets the count register to be its value modulo \meta{n}. 
% This is used for the
% date, time, ordinal and numberstring commands. (The fmtcount
% package was originally part of the datetime package.)
%    \begin{macrocode}
\newcount\@DT@modctr
\def\@modulo#1#2{%
\@DT@modctr=#1\relax
\divide \@DT@modctr by #2\relax
\multiply \@DT@modctr by #2\relax
\advance #1 by -\@DT@modctr}
%    \end{macrocode}
%\end{macro}
% The following registers are needed by |\@ordinal| etc
%    \begin{macrocode}
\newcount\@ordinalctr
\newcount\@orgargctr
\newcount\@strctr
\newcount\@tmpstrctr
%    \end{macrocode}
%Define commands that display numbers in different bases.
% Define counters and conditionals needed.
%    \begin{macrocode}
\newif\if@DT@padzeroes
\newcount\@DT@loopN
\newcount\@DT@X
%    \end{macrocode}
%\begin{macro}{\binarynum}
% Converts a decimal number to binary, and display.
%    \begin{macrocode}
\newcommand*{\@binary}[1]{%
\@DT@padzeroestrue
\@DT@loopN=17\relax
\@strctr=\@DT@loopN
\whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
\@strctr=65536\relax
\@DT@X=#1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes} \and \(\@DT@modctr=0\) \and \(\@DT@loopN>\c@padzeroesN\)}{}{\the\@DT@modctr}%
\ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 2\relax
\advance\@DT@loopN by -1\relax
\ifnum\@strctr>1
\repeat
\the\@DT@X}

\let\binarynum=\@binary
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octalnum}
% Converts a decimal number to octal, and displays.
%    \begin{macrocode}
\newcommand*{\@octal}[1]{%
\ifnum#1>32768
\PackageError{fmtcount}{Value of counter too large for \protect\@octal}{Maximum value 32768}
\else
\@DT@padzeroestrue
\@DT@loopN=6\relax
\@strctr=\@DT@loopN
\whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
\@strctr=32768\relax
\@DT@X=#1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes} \and \(\@DT@modctr=0\) \and \(\@DT@loopN>\c@padzeroesN\)}{}{\the\@DT@modctr}%
\ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 8\relax
\advance\@DT@loopN by -1\relax
\ifnum\@strctr>1
\repeat
\the\@DT@X
\fi}
\let\octalnum=\@octal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimalnum}
% Converts a decimal number to a lowercase hexadecimal number, 
% and displays it.
%    \begin{macrocode}
\newcommand*{\@@hexadecimal}[1]{\ifcase#10\or1\or2\or3\or4\or5\or
6\or7\or8\or9\or a\or b\or c\or d\or e\or f\fi}

\newcommand*{\@hexadecimal}[1]{%
\@DT@padzeroestrue
\@DT@loopN=5\relax
\@strctr=\@DT@loopN
\whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
\@strctr=65536\relax
\@DT@X=#1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes}\and\(\@DT@modctr=0\)\and
\(\@DT@loopN>\c@padzeroesN\)}{}{\@@hexadecimal\@DT@modctr}%
\ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 16\relax
\advance\@DT@loopN by -1\relax
\ifnum\@strctr>1
\repeat
\@@hexadecimal\@DT@X}

\let\hexadecimalnum=\@hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimalnum}
% Uppercase hexadecimal
%    \begin{macrocode}
\newcommand*{\@@Hexadecimal}[1]{\ifcase#10\or1\or2\or3\or4\or5\or6\or
7\or8\or9\or A\or B\or C\or D\or E\or F\fi}

\newcommand*{\@Hexadecimal}[1]{%
\@DT@padzeroestrue
\@DT@loopN=5\relax
\@strctr=\@DT@loopN
\whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
\@strctr=65536\relax
\@DT@X=#1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes} \and \(\@DT@modctr=0\) \and \(\@DT@loopN>\c@padzeroesN\)}{}{\@@Hexadecimal\@DT@modctr}%
\ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 16\relax
\advance\@DT@loopN by -1\relax
\ifnum\@strctr>1
\repeat
\@@Hexadecimal\@DT@X}

\let\Hexadecimalnum=\@Hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalphnum}
% Lowercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@aaalph}[1]{%
\@DT@loopN=#1\relax
\advance\@DT@loopN by -1\relax
\divide\@DT@loopN by 26\relax
\@DT@modctr=\@DT@loopN
\multiply\@DT@modctr by 26\relax
\@DT@X=#1\relax
\advance\@DT@X by -1\relax
\advance\@DT@X by -\@DT@modctr
\advance\@DT@loopN by 1\relax
\advance\@DT@X by 1\relax
\loop
\@alph\@DT@X
\advance\@DT@loopN by -1\relax
\ifnum\@DT@loopN>0
\repeat
}

\let\aaalphnum=\@aaalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlphnum}
% Uppercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@AAAlph}[1]{%
\@DT@loopN=#1\relax
\advance\@DT@loopN by -1\relax
\divide\@DT@loopN by 26\relax
\@DT@modctr=\@DT@loopN
\multiply\@DT@modctr by 26\relax
\@DT@X=#1\relax
\advance\@DT@X by -1\relax
\advance\@DT@X by -\@DT@modctr
\advance\@DT@loopN by 1\relax
\advance\@DT@X by 1\relax
\loop
\@Alph\@DT@X
\advance\@DT@loopN by -1\relax
\ifnum\@DT@loopN>0
\repeat
}

\let\AAAlphnum=\@AAAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalphnum}
% Lowercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@abalph}[1]{%
\ifnum#1>17576\relax
\PackageError{fmtcount}{Value of counter too large for 
\protect\@abalph}{Maximum value 17576}%
\else
\@DT@padzeroestrue
\@strctr=17576\relax
\@DT@X=#1\relax
\advance\@DT@X by -1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes}\and
\(\@DT@modctr=1\)}{}{\@alph\@DT@modctr}%
\ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 26\relax
\ifnum\@strctr>1
\repeat
\advance\@DT@X by 1\relax
\@alph\@DT@X
\fi}

\let\abalphnum=\@abalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlphnum}
% Uppercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@ABAlph}[1]{%
\ifnum#1>17576\relax
\PackageError{fmtcount}{Value of counter too large for 
\protect\@ABAlph}{Maximum value 17576}%
\else
\@DT@padzeroestrue
\@strctr=17576\relax
\@DT@X=#1\relax
\advance\@DT@X by -1\relax
\loop
\@DT@modctr=\@DT@X
\divide\@DT@modctr by \@strctr
\ifthenelse{\boolean{@DT@padzeroes}\and
\(\@DT@modctr=1\)}{}{\@Alph\@DT@modctr}%
\ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
\multiply\@DT@modctr by \@strctr
\advance\@DT@X by -\@DT@modctr
\divide\@strctr by 26\relax
\ifnum\@strctr>1
\repeat
\advance\@DT@X by 1\relax
\@Alph\@DT@X
\fi}

\let\ABAlphnum=\@ABAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fmtc@count}
% Recursive command to count number of characters in argument.
% |\@strctr| should be set to zero before calling it.
%    \begin{macrocode}
\def\@fmtc@count#1#2\relax{%
\if\relax#1
\else
\advance\@strctr by 1\relax
\@fmtc@count#2\relax
\fi}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@decimal}
%\changes{1.31}{2009/10/02}{fixed unwanted space.}
% Format number as a decimal, possibly padded with zeroes in front.
%    \begin{macrocode}
\newcommand{\@decimal}[1]{%
\@strctr=0\relax
\expandafter\@fmtc@count\number#1\relax
\@DT@loopN=\c@padzeroesN
\advance\@DT@loopN by -\@strctr
\ifnum\@DT@loopN>0\relax
\@strctr=0\relax
\whiledo{\@strctr < \@DT@loopN}{0\advance\@strctr by 1\relax}%
\fi
\number#1\relax
}

\let\decimalnum=\@decimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FCordinal}
%\begin{definition}
%\cs{FCordinal}\marg{number}
%\end{definition}
% This is a bit cumbersome.  Previously \cs{@ordinal}
% was defined in a similar way to \cs{abalph} etc.
% This ensured that the actual value of the counter was
% written in the new label stuff in the .aux file. However
% adding in an optional argument to determine the gender
% for multilingual compatibility messed things up somewhat.
% This was the only work around I could get to keep the
% the cross-referencing stuff working, which is why
% the optional argument comes \emph{after} the compulsory
% argument, instead of the usual manner of placing it before.
% Note however, that putting the optional argument means that
% any spaces will be ignored after the command if the optional
% argument is omitted.
% Version 1.04 changed \cs{ordinal} to \cs{FCordinal}
% to prevent it clashing with the memoir class. 
%    \begin{macrocode}
\newcommand{\FCordinal}[1]{%
\expandafter\protect\expandafter\ordinalnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinal}
% If \cs{ordinal} isn't defined make \cs{ordinal} a synonym
% for \cs{FCordinal} to maintain compatibility with previous
% versions.
%    \begin{macrocode}
\@ifundefined{ordinal}{\let\ordinal\FCordinal}{%
\PackageWarning{fmtcount}{\string\ordinal
\space already defined use \string\FCordinal \space instead.}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalnum}
% Display ordinal where value is given as a number or 
% count register instead of a counter:
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ordinalnum}[1]{\new@ifnextchar[{\@ordinalnum{#1}}{%
\@ordinalnum{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinalnum}
% Display ordinal according to gender (neuter added in v1.1,
% \cs{xspace} added in v1.2, and removed in v1.3\footnote{I
%couldn't get it to work consistently both with and without the
%optional argument}):
%    \begin{macrocode}
\def\@ordinalnum#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
 \protect\@ordinalF{#1}{\@fc@ordstr}%
 }{%
   \ifthenelse{\equal{#2}{n}}{%
      \protect\@ordinalN{#1}{\@fc@ordstr}%
    }{%
      \ifthenelse{\equal{#2}{m}}{}{%
        \PackageError{fmtcount}{Invalid gender option `#2'}{%
           Available options are m, f or n}%
      }%
      \protect\@ordinalM{#1}{\@fc@ordstr}%
    }%
 }%
\@fc@ordstr
}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinal}
% Store the ordinal (first argument
% is identifying name, second argument is a counter.)
%    \begin{macrocode}
\newcommand*{\storeordinal}[2]{%
\expandafter\protect\expandafter\storeordinalnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalnum}
% Store ordinal (first argument
% is identifying name, second argument is a number or
% count register.)
%    \begin{macrocode}
\newcommand*{\storeordinalnum}[2]{%
\@ifnextchar[{\@storeordinalnum{#1}{#2}}{%
\@storeordinalnum{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@storeordinalnum}
% Store ordinal according to gender:
%    \begin{macrocode}
\def\@storeordinalnum#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@ordinalF{#2}{\@fc@ord}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@ordinalN{#2}{\@fc@ord}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m or f}}%
\protect\@ordinalM{#2}{\@fc@ord}}}%
\expandafter\let\csname @fcs@#1\endcsname\@fc@ord}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FMCuse}
% Get stored information:
%    \begin{macrocode}
\newcommand*{\FMCuse}[1]{\csname @fcs@#1\endcsname}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstring}
% Display ordinal as a string (argument is a counter)
%    \begin{macrocode}
\newcommand*{\ordinalstring}[1]{%
\expandafter\protect\expandafter\ordinalstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstringnum}
% Display ordinal as a string (argument is a count register or
% number.)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand{\ordinalstringnum}[1]{%
\new@ifnextchar[{\@ordinal@string{#1}}{\@ordinal@string{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinal@string}
% Display ordinal as a string according to gender.
%    \begin{macrocode}
\def\@ordinal@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@ordinalstringF{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@ordinalstringN{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2' to 
\string\ordinalstring}{Available options are m, f or f}}%
\protect\@ordinalstringM{#1}{\@fc@ordstr}}}\@fc@ordstr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeordinalstring}[2]{%
\expandafter\protect\expandafter\storeordinalstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstringnum}
% Store textual representation of number. First argument is 
% identifying name, second argument is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeordinalstringnum}[2]{%
\@ifnextchar[{\@store@ordinal@string{#1}{#2}}{%
\@store@ordinal@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ordinal@string}
% Store textual representation of number according to gender.
%    \begin{macrocode}
\def\@store@ordinal@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@ordinalstringF{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@ordinalstringN{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3' to 
\string\ordinalstring}{Available options are m, f or n}}%
\protect\@ordinalstringM{#2}{\@fc@ordstr}}}%
\expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstring}
% Display ordinal as a string with initial letters in upper case
% (argument is a counter)
%    \begin{macrocode}
\newcommand*{\Ordinalstring}[1]{%
\expandafter\protect\expandafter\Ordinalstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstringnum}
% Display ordinal as a string with initial letters in upper case
% (argument is a number or count register)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Ordinalstringnum}[1]{%
\new@ifnextchar[{\@Ordinal@string{#1}}{\@Ordinal@string{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Ordinal@string}
% Display ordinal as a string with initial letters in upper case
% according to gender
%    \begin{macrocode}
\def\@Ordinal@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@OrdinalstringF{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@OrdinalstringN{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2'}{%
Available options are m, f or n}}%
\protect\@OrdinalstringM{#1}{\@fc@ordstr}}}\@fc@ordstr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstring}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstring}[2]{%
\expandafter\protect\expandafter\storeOrdinalstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstringnum}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstringnum}[2]{%
\@ifnextchar[{\@store@Ordinal@string{#1}{#2}}{%
\@store@Ordinal@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Ordinal@string}
% Store textual representation of number according to gender, 
% with initial letters in upper case.
%    \begin{macrocode}
\def\@store@Ordinal@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@OrdinalstringF{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@OrdinalstringN{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m or f}}%
\protect\@OrdinalstringM{#2}{\@fc@ordstr}}}%
\expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\storeORDINALstring}
% Store upper case textual representation of ordinal. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeORDINALstring}[2]{%
\expandafter\protect\expandafter\storeORDINALstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeORDINALstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand*{\storeORDINALstringnum}[2]{%
\@ifnextchar[{\@store@ORDINAL@string{#1}{#2}}{%
\@store@ORDINAL@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@ORDINAL@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@ordinalstringF{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@ordinalstringN{#2}{\@fc@ordstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m or f}}%
\protect\@ordinalstringM{#2}{\@fc@ordstr}}}%
\expandafter\edef\csname @fcs@#1\endcsname{%
\noexpand\MakeUppercase{\@fc@ordstr}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstring}
% Display upper case textual representation of an ordinal. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\ORDINALstring}[1]{%
\expandafter\protect\expandafter\ORDINALstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ORDINALstringnum}[1]{%
\new@ifnextchar[{\@ORDINAL@string{#1}}{\@ORDINAL@string{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@ORDINAL@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@ordinalstringF{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@ordinalstringN{#1}{\@fc@ordstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2'}{%
Available options are m, f or n}}%
\protect\@ordinalstringM{#1}{\@fc@ordstr}}}%
\MakeUppercase{\@fc@ordstr}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstring}
% Convert number to textual respresentation, and store. First 
% argument is the identifying name, second argument is a counter 
% containing the number.
%    \begin{macrocode}
\newcommand*{\storenumberstring}[2]{%
\expandafter\protect\expandafter\storenumberstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstringnum}
% As above, but second argument is a number or count register.
%    \begin{macrocode}
\newcommand{\storenumberstringnum}[2]{%
\@ifnextchar[{\@store@number@string{#1}{#2}}{%
\@store@number@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@number@string}
% Gender is given as optional argument, \emph{at the end}.
%    \begin{macrocode}
\def\@store@number@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@numberstringF{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@numberstringN{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m, f or n}}%
\protect\@numberstringM{#2}{\@fc@numstr}}}%
\expandafter\let\csname @fcs@#1\endcsname\@fc@numstr}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstring}
% Display textual representation of a number. The argument
% must be a counter.
%    \begin{macrocode}
\newcommand*{\numberstring}[1]{%
\expandafter\protect\expandafter\numberstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\numberstringnum}[1]{%
\new@ifnextchar[{\@number@string{#1}}{\@number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\@number@string}
% Gender is specified as an optional argument \emph{at the end}.
%    \begin{macrocode}
\def\@number@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@numberstringF{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@numberstringN{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2'}{%
Available options are m, f or n}}%
\protect\@numberstringM{#1}{\@fc@numstr}}}\@fc@numstr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeNumberstring}[2]{%
\expandafter\protect\expandafter\storeNumberstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstringnum}
% As above, but second argument is a count register or number.
%    \begin{macrocode}
\newcommand{\storeNumberstringnum}[2]{%
\@ifnextchar[{\@store@Number@string{#1}{#2}}{%
\@store@Number@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Number@string}
% Gender is specified as an optional argument \emph{at the end}:
%    \begin{macrocode}
\def\@store@Number@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@NumberstringF{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@NumberstringN{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m, f or n}}%
\protect\@NumberstringM{#2}{\@fc@numstr}}}%
\expandafter\let\csname @fcs@#1\endcsname\@fc@numstr}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstring}
% Display textual representation of number. The argument must be
% a counter. 
%    \begin{macrocode}
\newcommand*{\Numberstring}[1]{%
\expandafter\protect\expandafter\Numberstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstringnum}
% As above, but the argument is a count register or number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Numberstringnum}[1]{%
\new@ifnextchar[{\@Number@string{#1}}{\@Number@string{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Number@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@Number@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@NumberstringF{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@NumberstringN{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2'}{%
Available options are m, f or n}}%
\protect\@NumberstringM{#1}{\@fc@numstr}}}\@fc@numstr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstring}
% Store upper case textual representation of number. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand{\storeNUMBERstring}[2]{%
\expandafter\protect\expandafter\storeNUMBERstringnum{#1}{%
\expandafter\the\csname c@#2\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand{\storeNUMBERstringnum}[2]{%
\@ifnextchar[{\@store@NUMBER@string{#1}{#2}}{%
\@store@NUMBER@string{#1}{#2}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@NUMBER@string#1#2[#3]{%
\ifthenelse{\equal{#3}{f}}{%
\protect\@numberstringF{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{n}}{%
\protect\@numberstringN{#2}{\@fc@numstr}}{%
\ifthenelse{\equal{#3}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#3'}{%
Available options are m or f}}%
\protect\@numberstringM{#2}{\@fc@numstr}}}%
\expandafter\edef\csname @fcs@#1\endcsname{%
\noexpand\MakeUppercase{\@fc@numstr}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstring}
% Display upper case textual representation of a number. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\NUMBERstring}[1]{%
\expandafter\protect\expandafter\NUMBERstringnum{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\NUMBERstringnum}[1]{%
\new@ifnextchar[{\@NUMBER@string{#1}}{\@NUMBER@string{#1}[m]}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@NUMBER@string#1[#2]{{%
\ifthenelse{\equal{#2}{f}}{%
\protect\@numberstringF{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{n}}{%
\protect\@numberstringN{#1}{\@fc@numstr}}{%
\ifthenelse{\equal{#2}{m}}{}{%
\PackageError{fmtcount}{Invalid gender option `#2'}{%
Available options are m, f or n}}%
\protect\@numberstringM{#1}{\@fc@numstr}}}%
\MakeUppercase{\@fc@numstr}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\binary}
% Number representations in other bases. Binary:
%    \begin{macrocode}
\providecommand*{\binary}[1]{%
\expandafter\protect\expandafter\@binary{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalph}
% Like \verb"\alph", but goes beyond 26.
% (a \ldots\ z aa \ldots zz \ldots)
%    \begin{macrocode}
\providecommand*{\aaalph}[1]{%
\expandafter\protect\expandafter\@aaalph{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlph}
% As before, but upper case.
%    \begin{macrocode}
\providecommand*{\AAAlph}[1]{%
\expandafter\protect\expandafter\@AAAlph{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalph}
% Like \verb"\alph", but goes beyond 26. 
% (a \ldots\ z ab \ldots az \ldots)
%    \begin{macrocode}
\providecommand*{\abalph}[1]{%
\expandafter\protect\expandafter\@abalph{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlph}
% As above, but upper case.
%    \begin{macrocode}
\providecommand*{\ABAlph}[1]{%
\expandafter\protect\expandafter\@ABAlph{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimal}
% Hexadecimal:
%    \begin{macrocode}
\providecommand*{\hexadecimal}[1]{%
\expandafter\protect\expandafter\@hexadecimal{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimal}
% As above, but in upper case.
%    \begin{macrocode}
\providecommand*{\Hexadecimal}[1]{%
\expandafter\protect\expandafter\@Hexadecimal{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octal}
% Octal:
%    \begin{macrocode}
\providecommand*{\octal}[1]{%
\expandafter\protect\expandafter\@octal{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\decimal}
% Decimal:
%    \begin{macrocode}
\providecommand*{\decimal}[1]{%
\expandafter\protect\expandafter\@decimal{%
\expandafter\the\csname c@#1\endcsname}}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Multilinguage Definitions}
%\begin{macro}{\@setdef@ultfmtcount}
% If multilingual support is provided, make \verb"\@numberstring" 
% etc use the correct language (if defined).
% Otherwise use English definitions. "\@setdef@ultfmtcount"
% sets the macros to use English.
%    \begin{macrocode}
\def\@setdef@ultfmtcount{
\@ifundefined{@ordinalMenglish}{\input{fc-english.def}}{}
\def\@ordinalstringM{\@ordinalstringMenglish}
\let\@ordinalstringF=\@ordinalstringMenglish
\let\@ordinalstringN=\@ordinalstringMenglish
\def\@OrdinalstringM{\@OrdinalstringMenglish}
\let\@OrdinalstringF=\@OrdinalstringMenglish
\let\@OrdinalstringN=\@OrdinalstringMenglish
\def\@numberstringM{\@numberstringMenglish}
\let\@numberstringF=\@numberstringMenglish
\let\@numberstringN=\@numberstringMenglish
\def\@NumberstringM{\@NumberstringMenglish}
\let\@NumberstringF=\@NumberstringMenglish
\let\@NumberstringN=\@NumberstringMenglish
\def\@ordinalM{\@ordinalMenglish}
\let\@ordinalF=\@ordinalM
\let\@ordinalN=\@ordinalM
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@set@mulitling@fmtcount}
% This defines the number and ordinal string macros to use 
% \cs{languagename}:
%    \begin{macrocode}
\def\@set@mulitling@fmtcount{%
%    \end{macrocode}
% The masculine version of \cs{numberstring}:
%    \begin{macrocode}
\def\@numberstringM{\@ifundefined{@numberstringM\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@numberstringM}}{%
\csname @numberstringM\languagename\endcsname}}%
%    \end{macrocode}
% The feminine version of \cs{numberstring}:
%    \begin{macrocode}
\def\@numberstringF{\@ifundefined{@numberstringF\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@numberstringF}}{%
\csname @numberstringF\languagename\endcsname}}%
%    \end{macrocode}
% The neuter version of \cs{numberstring}:
%    \begin{macrocode}
\def\@numberstringN{\@ifundefined{@numberstringN\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@numberstringN}}{%
\csname @numberstringN\languagename\endcsname}}%
%    \end{macrocode}
% The masculine version of \cs{Numberstring}:
%    \begin{macrocode}
\def\@NumberstringM{\@ifundefined{@NumberstringM\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@NumberstringM}}{%
\csname @NumberstringM\languagename\endcsname}}%
%    \end{macrocode}
% The feminine version of \cs{Numberstring}:
%    \begin{macrocode}
\def\@NumberstringF{\@ifundefined{@NumberstringF\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@NumberstringF}}{%
\csname @NumberstringF\languagename\endcsname}}%
%    \end{macrocode}
% The neuter version of \cs{Numberstring}:
%    \begin{macrocode}
\def\@NumberstringN{\@ifundefined{@NumberstringN\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@NumberstringN}}{%
\csname @NumberstringN\languagename\endcsname}}%
%    \end{macrocode}
% The masculine version of \cs{ordinal}:
%    \begin{macrocode}
\def\@ordinalM{\@ifundefined{@ordinalM\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalM}}{%
\csname @ordinalM\languagename\endcsname}}%
%    \end{macrocode}
% The feminine version of \cs{ordinal}:
%    \begin{macrocode}
\def\@ordinalF{\@ifundefined{@ordinalF\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalF}}{%
\csname @ordinalF\languagename\endcsname}}%
%    \end{macrocode}
% The neuter version of \cs{ordinal}:
%    \begin{macrocode}
\def\@ordinalN{\@ifundefined{@ordinalN\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalN}}{%
\csname @ordinalN\languagename\endcsname}}%
%    \end{macrocode}
% The masculine version of \cs{ordinalstring}:
%    \begin{macrocode}
\def\@ordinalstringM{\@ifundefined{@ordinalstringM\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalstringM}}{%
\csname @ordinalstringM\languagename\endcsname}}%
%    \end{macrocode}
% The feminine version of \cs{ordinalstring}:
%    \begin{macrocode}
\def\@ordinalstringF{\@ifundefined{@ordinalstringF\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalstringF}}{%
\csname @ordinalstringF\languagename\endcsname}}%
%    \end{macrocode}
% The neuter version of \cs{ordinalstring}:
%    \begin{macrocode}
\def\@ordinalstringN{\@ifundefined{@ordinalstringN\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@ordinalstringN}}{%
\csname @ordinalstringN\languagename\endcsname}}%
%    \end{macrocode}
% The masculine version of \cs{Ordinalstring}:
%    \begin{macrocode}
\def\@OrdinalstringM{\@ifundefined{@OrdinalstringM\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@OrdinalstringM}}{%
\csname @OrdinalstringM\languagename\endcsname}}%
%    \end{macrocode}
% The feminine version of \cs{Ordinalstring}:
%    \begin{macrocode}
\def\@OrdinalstringF{\@ifundefined{@OrdinalstringF\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@OrdinalstringF}}{%
\csname @OrdinalstringF\languagename\endcsname}}%
%    \end{macrocode}
% The neuter version of \cs{Ordinalstring}:
%    \begin{macrocode}
\def\@OrdinalstringN{\@ifundefined{@OrdinalstringN\languagename}{%
\PackageError{fmtcount}{No support for language '\languagename'}{%
The fmtcount package currently does not support language 
'\languagename' for command \string\@OrdinalstringN}}{%
\csname @OrdinalstringN\languagename\endcsname}}
}
%    \end{macrocode}
%\end{macro}
% Check to see if babel or ngerman packages have been loaded.
%    \begin{macrocode}
\@ifpackageloaded{babel}{%
\ifthenelse{\equal{\languagename}{nohyphenation}\or
\equal{languagename}{english}}{\@setdef@ultfmtcount}{%
\@set@mulitling@fmtcount}
}{%
\@ifpackageloaded{ngerman}{%
\@ifundefined{@numberstringMgerman}{%
\input{fc-german.def}}{}\@set@mulitling@fmtcount}{%
\@setdef@ultfmtcount}}
%    \end{macrocode}
% Backwards compatibility:
%    \begin{macrocode}
\let\@ordinal=\@ordinalM
\let\@ordinalstring=\@ordinalstringM
\let\@Ordinalstring=\@OrdinalstringM
\let\@numberstring=\@numberstringM
\let\@Numberstring=\@NumberstringM
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fmtcount.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-british.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-british.def}
% British definitions
%    \begin{macrocode}
\ProvidesFile{fc-british}[2007/06/14]
%    \end{macrocode}
% Check that fc-english.def has been loaded
%    \begin{macrocode}
\@ifundefined{@ordinalMenglish}{\input{fc-english.def}}{}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\let\@ordinalMbritish\@ordinalMenglish
\let\@ordinalFbritish\@ordinalMenglish
\let\@ordinalNbritish\@ordinalMenglish
\let\@numberstringMbritish\@numberstringMenglish
\let\@numberstringFbritish\@numberstringMenglish
\let\@numberstringNbritish\@numberstringMenglish
\let\@NumberstringMbritish\@NumberstringMenglish
\let\@NumberstringFbritish\@NumberstringMenglish
\let\@NumberstringNbritish\@NumberstringMenglish
\let\@ordinalstringMbritish\@ordinalstringMenglish
\let\@ordinalstringFbritish\@ordinalstringMenglish
\let\@ordinalstringNbritish\@ordinalstringMenglish
\let\@OrdinalstringMbritish\@OrdinalstringMenglish
\let\@OrdinalstringFbritish\@OrdinalstringMenglish
\let\@OrdinalstringNbritish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-british.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-english.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-english.def}
% English definitions
%    \begin{macrocode}
\ProvidesFile{fc-english}[2007/05/26]
%    \end{macrocode}
% Define macro that converts a number or count register (first 
% argument) to an ordinal, and stores the result in the 
% second argument, which should be a control sequence.
%    \begin{macrocode}
\newcommand*{\@ordinalMenglish}[2]{%
\def\@fc@ord{}%
\@orgargctr=#1\relax
\@ordinalctr=#1%
\@modulo{\@ordinalctr}{100}%
\ifnum\@ordinalctr=11\relax
  \def\@fc@ord{th}%
\else
  \ifnum\@ordinalctr=12\relax
    \def\@fc@ord{th}%
  \else
    \ifnum\@ordinalctr=13\relax
      \def\@fc@ord{th}%
    \else
      \@modulo{\@ordinalctr}{10}%
      \ifcase\@ordinalctr
        \def\@fc@ord{th}%      case 0
        \or \def\@fc@ord{st}%  case 1
        \or \def\@fc@ord{nd}%  case 2
        \or \def\@fc@ord{rd}%  case 3
      \else
        \def\@fc@ord{th}%      default case
      \fi
    \fi
  \fi
\fi
\edef#2{\number#1\relax\noexpand\fmtord{\@fc@ord}}%
}
%    \end{macrocode}
% There is no gender difference in English, so make feminine and
% neuter the same as the masculine.
%    \begin{macrocode}
\let\@ordinalFenglish=\@ordinalMenglish
\let\@ordinalNenglish=\@ordinalMenglish
%    \end{macrocode}
% Define the macro that prints the value of a \TeX\ count register
% as text. To make it easier, break it up into units, teens and
% tens. First, the units: the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@unitstringenglish}[1]{%
\ifcase#1\relax
zero%
\or one%
\or two%
\or three%
\or four%
\or five%
\or six%
\or seven%
\or eight%
\or nine%
\fi
}
%    \end{macrocode}
% Next the tens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@tenstringenglish}[1]{%
\ifcase#1\relax
\or ten%
\or twenty%
\or thirty%
\or forty%
\or fifty%
\or sixty%
\or seventy%
\or eighty%
\or ninety%
\fi
}
%    \end{macrocode}
% Finally the teens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@teenstringenglish}[1]{%
\ifcase#1\relax
ten%
\or eleven%
\or twelve%
\or thirteen%
\or fourteen%
\or fifteen%
\or sixteen%
\or seventeen%
\or eighteen%
\or nineteen%
\fi
}
%    \end{macrocode}
% As above, but with the initial letter in uppercase. The units:
%    \begin{macrocode}
\newcommand*{\@@Unitstringenglish}[1]{%
\ifcase#1\relax
Zero%
\or One%
\or Two%
\or Three%
\or Four%
\or Five%
\or Six%
\or Seven%
\or Eight%
\or Nine%
\fi
}
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*{\@@Tenstringenglish}[1]{%
\ifcase#1\relax
\or Ten%
\or Twenty%
\or Thirty%
\or Forty%
\or Fifty%
\or Sixty%
\or Seventy%
\or Eighty%
\or Ninety%
\fi
}
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*{\@@Teenstringenglish}[1]{%
\ifcase#1\relax
Ten%
\or Eleven%
\or Twelve%
\or Thirteen%
\or Fourteen%
\or Fifteen%
\or Sixteen%
\or Seventeen%
\or Eighteen%
\or Nineteen%
\fi
}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros are
% not meant for use in documents.)
%    \begin{macrocode}
\newcommand*{\@@numberstringenglish}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
% #1 is greater or equal to 10000
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
   \ifnum#1>1000\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ }%
   \fi
   \let\@@fc@numstr#2\relax
   \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@hundred}%
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
       \ifnum#1<100\relax
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
       \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% All lower case version, the second argument must be a 
% control sequence.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMenglish}[2]{%
\let\@unitstring=\@@unitstringenglish 
\let\@teenstring=\@@teenstringenglish 
\let\@tenstring=\@@tenstringenglish
\def\@hundred{hundred}\def\@thousand{thousand}%
\def\@andname{and}%
\@@numberstringenglish{#1}{#2}%
}
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the same
% as the masculine.
%    \begin{macrocode}
\let\@numberstringFenglish=\@numberstringMenglish
\let\@numberstringNenglish=\@numberstringMenglish
%    \end{macrocode}
% This version makes the first letter of each word an uppercase
% character (except ``and''). The second argument must be a control 
% sequence.
%    \begin{macrocode}
\newcommand*{\@NumberstringMenglish}[2]{%
\let\@unitstring=\@@Unitstringenglish 
\let\@teenstring=\@@Teenstringenglish 
\let\@tenstring=\@@Tenstringenglish
\def\@hundred{Hundred}\def\@thousand{Thousand}%
\def\@andname{and}%
\@@numberstringenglish{#1}{#2}}
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the same
% as the masculine.
%    \begin{macrocode}
\let\@NumberstringFenglish=\@NumberstringMenglish
\let\@NumberstringNenglish=\@NumberstringMenglish
%    \end{macrocode}
% Define a macro that produces an ordinal as a string. Again, break
% it up into units, teens and tens. First the units:
%    \begin{macrocode}
\newcommand*{\@@unitthstringenglish}[1]{%
\ifcase#1\relax
zeroth%
\or first%
\or second%
\or third%
\or fourth%
\or fifth%
\or sixth%
\or seventh%
\or eighth%
\or ninth%
\fi
}
%    \end{macrocode}
% Next the tens:
%    \begin{macrocode}
\newcommand*{\@@tenthstringenglish}[1]{%
\ifcase#1\relax
\or tenth%
\or twentieth%
\or thirtieth%
\or fortieth%
\or fiftieth%
\or sixtieth%
\or seventieth%
\or eightieth%
\or ninetieth%
\fi
}
%   \end{macrocode}
% The teens:
%   \begin{macrocode}
\newcommand*{\@@teenthstringenglish}[1]{%
\ifcase#1\relax
tenth%
\or eleventh%
\or twelfth%
\or thirteenth%
\or fourteenth%
\or fifteenth%
\or sixteenth%
\or seventeenth%
\or eighteenth%
\or nineteenth%
\fi
}
%   \end{macrocode}
% As before, but with the first letter in upper case. The units:
%   \begin{macrocode}
\newcommand*{\@@Unitthstringenglish}[1]{%
\ifcase#1\relax
Zeroth%
\or First%
\or Second%
\or Third%
\or Fourth%
\or Fifth%
\or Sixth%
\or Seventh%
\or Eighth%
\or Ninth%
\fi
}
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*{\@@Tenthstringenglish}[1]{%
\ifcase#1\relax
\or Tenth%
\or Twentieth%
\or Thirtieth%
\or Fortieth%
\or Fiftieth%
\or Sixtieth%
\or Seventieth%
\or Eightieth%
\or Ninetieth%
\fi
}
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*{\@@Teenthstringenglish}[1]{%
\ifcase#1\relax
Tenth%
\or Eleventh%
\or Twelfth%
\or Thirteenth%
\or Fourteenth%
\or Fifteenth%
\or Sixteenth%
\or Seventeenth%
\or Eighteenth%
\or Nineteenth%
\fi
}
%    \end{macrocode}
% Again, as from version 1.09, this has been changed to take two
% arguments, where the second argument is a control sequence.
% The resulting text is stored in the control sequence, and nothing
% is displayed.
%    \begin{macrocode}
\newcommand*{\@@ordinalstringenglish}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000 (value given: \number\@strctr)}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\def#2{}%
\fi
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
% #1 is greater or equal to 10000
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@modulo{\@strctr}{1000}%
  \ifnum\@strctr=0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousandth}%
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousand}%
  \fi
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \@strctr=#1\relax \@modulo{\@strctr}{1000}%
    \let\@@fc@ordstr#2\relax
    \ifnum\@strctr=0\relax
      \edef#2{\@@fc@ordstr\ \@thousandth}%
    \else
      \edef#2{\@@fc@ordstr\ \@thousand}%
    \fi
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{100}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@strctr=0\relax
    \edef#2{\@@fc@ordstr\ \@hundredth}%
  \else
    \edef#2{\@@fc@ordstr\ \@hundred}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \@modulo{\@tmpstrctr}{10}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@tmpstrctr=0\relax
    \edef#2{\@@fc@ordstr\@tenthstring{\@strctr}}%
  \else
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-\@unitthstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \else
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% All lower case version. Again, the second argument must be a
% control sequence in which the resulting text is stored.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMenglish}[2]{%
\let\@unitthstring=\@@unitthstringenglish 
\let\@teenthstring=\@@teenthstringenglish 
\let\@tenthstring=\@@tenthstringenglish
\let\@unitstring=\@@unitstringenglish 
\let\@teenstring=\@@teenstringenglish
\let\@tenstring=\@@tenstringenglish
\def\@andname{and}%
\def\@hundred{hundred}\def\@thousand{thousand}%
\def\@hundredth{hundredth}\def\@thousandth{thousandth}%
\@@ordinalstringenglish{#1}{#2}}
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringFenglish=\@ordinalstringMenglish
\let\@ordinalstringNenglish=\@ordinalstringMenglish
%    \end{macrocode}
% First letter of each word in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMenglish}[2]{%
\let\@unitthstring=\@@Unitthstringenglish
\let\@teenthstring=\@@Teenthstringenglish
\let\@tenthstring=\@@Tenthstringenglish
\let\@unitstring=\@@Unitstringenglish
\let\@teenstring=\@@Teenstringenglish
\let\@tenstring=\@@Tenstringenglish
\def\@andname{and}%
\def\@hundred{Hundred}\def\@thousand{Thousand}%
\def\@hundredth{Hundredth}\def\@thousandth{Thousandth}%
\@@ordinalstringenglish{#1}{#2}}
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringFenglish=\@OrdinalstringMenglish
\let\@OrdinalstringNenglish=\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-english.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-french.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-french.def}
% French definitions
%    \begin{macrocode}
\ProvidesFile{fc-french.def}[2007/05/26]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and store the result in the second
% argument, which must be a control sequence. Masculine:
%    \begin{macrocode}
\newcommand*{\@ordinalMfrench}[2]{%
\iffmtord@abbrv
  \edef#2{\number#1\relax\noexpand\fmtord{e}}%
\else
  \ifnum#1=1\relax
    \edef#2{\number#1\relax\noexpand\fmtord{er}}%
  \else
    \edef#2{\number#1\relax\noexpand\fmtord{eme}}%
  \fi
\fi}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand*{\@ordinalFfrench}[2]{%
\iffmtord@abbrv
  \edef#2{\number#1\relax\noexpand\fmtord{e}}%
\else
  \ifnum#1=1\relax
     \edef#2{\number#1\relax\noexpand\fmtord{ere}}%
  \else
     \edef#2{\number#1\relax\noexpand\fmtord{eme}}%
  \fi
\fi}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalNfrench\@ordinalMfrench
%    \end{macrocode}
% Textual representation of a number. To make it easier break it
% into units, tens and teens. First the units:
%   \begin{macrocode}
\newcommand*{\@@unitstringfrench}[1]{%
\ifcase#1\relax
zero%
\or un%
\or deux%
\or trois%
\or quatre%
\or cinq%
\or six%
\or sept%
\or huit%
\or neuf%
\fi
}
%    \end{macrocode}
% Feminine only changes for 1:
%    \begin{macrocode}
\newcommand*{\@@unitstringFfrench}[1]{%
\ifnum#1=1\relax
une%
\else\@@unitstringfrench{#1}%
\fi
}
%    \end{macrocode}
% Tens (this includes the Belgian and Swiss variants, special
% cases employed lower down.)
%    \begin{macrocode}
\newcommand*{\@@tenstringfrench}[1]{%
\ifcase#1\relax
\or dix%
\or vingt%
\or trente%
\or quarante%
\or cinquante%
\or soixante%
\or septente%
\or huitante%
\or nonente%
\or cent%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*{\@@teenstringfrench}[1]{%
\ifcase#1\relax
dix%
\or onze%
\or douze%
\or treize%
\or quatorze%
\or quinze%
\or seize%
\or dix-sept%
\or dix-huit%
\or dix-neuf%
\fi
}
%    \end{macrocode}
% Seventies are a special case, depending on dialect:
%    \begin{macrocode}
\newcommand*{\@@seventiesfrench}[1]{%
\@tenstring{6}%
\ifnum#1=1\relax
\ \@andname\ 
\else
-%
\fi
\@teenstring{#1}%
}
%    \end{macrocode}
% Eighties are a special case, depending on dialect:
%    \begin{macrocode}
\newcommand*{\@@eightiesfrench}[1]{%
\@unitstring{4}-\@tenstring{2}%
\ifnum#1>0
-\@unitstring{#1}%
\else
s%
\fi
}
%    \end{macrocode}
% Nineties are a special case, depending on dialect:
%    \begin{macrocode}
\newcommand*{\@@ninetiesfrench}[1]{%
\@unitstring{4}-\@tenstring{2}-\@teenstring{#1}%
}
%    \end{macrocode}
% Swiss seventies:
%    \begin{macrocode}
\newcommand*{\@@seventiesfrenchswiss}[1]{%
\@tenstring{7}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0\@unitstring{#1}\fi
}
%    \end{macrocode}
% Swiss eighties:
%    \begin{macrocode}
\newcommand*{\@@eightiesfrenchswiss}[1]{%
\@tenstring{8}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0\@unitstring{#1}\fi
}
%    \end{macrocode}
% Swiss nineties:
%    \begin{macrocode}
\newcommand*{\@@ninetiesfrenchswiss}[1]{%
\@tenstring{9}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0\@unitstring{#1}\fi
}
%    \end{macrocode}
% Units with initial letter in upper case:
%    \begin{macrocode}
\newcommand*{\@@Unitstringfrench}[1]{%
\ifcase#1\relax
Zero%
\or Un%
\or Deux%
\or Trois%
\or Quatre%
\or Cinq%
\or Six%
\or Sept%
\or Huit%
\or Neuf%
\fi
}
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*{\@@UnitstringFfrench}[1]{%
\ifnum#1=1\relax
Une%
\else \@@Unitstringfrench{#1}%
\fi
}
%    \end{macrocode}
% Tens, with initial letter in upper case (includes Swiss and
% Belgian variants):
%    \begin{macrocode}
\newcommand*{\@@Tenstringfrench}[1]{%
\ifcase#1\relax
\or Dix%
\or Vingt%
\or Trente%
\or Quarante%
\or Cinquante%
\or Soixante%
\or Septente%
\or Huitante%
\or Nonente%
\or Cent%
\fi
}
%    \end{macrocode}
% Teens, with initial letter in upper case:
%    \begin{macrocode}
\newcommand*{\@@Teenstringfrench}[1]{%
\ifcase#1\relax
Dix%
\or Onze%
\or Douze%
\or Treize%
\or Quatorze%
\or Quinze%
\or Seize%
\or Dix-Sept%
\or Dix-Huit%
\or Dix-Neuf%
\fi
}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros
% are not defined for use in documents.) Firstly, the Swiss
% version:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMfrenchswiss}[2]{%
\let\@unitstring=\@@unitstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Same as above, but for French as spoken in France:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMfrenchfrance}[2]{%
\let\@unitstring=\@@unitstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Same as above, but for Belgian dialect:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMfrenchbelgian}[2]{%
\let\@unitstring=\@@unitstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Set default dialect:
%    \begin{macrocode}
\let\@numberstringMfrench=\@numberstringMfrenchfrance
%    \end{macrocode}
% As above, but for feminine version. Swiss:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFfrenchswiss}[2]{%
\let\@unitstring=\@@unitstringFfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% French:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFfrenchfrance}[2]{%
\let\@unitstring=\@@unitstringFfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Belgian:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFfrenchbelgian}[2]{%
\let\@unitstring=\@@unitstringFfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{cent}\def\@thousand{mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Set default dialect:
%    \begin{macrocode}
\let\@numberstringFfrench=\@numberstringFfrenchfrance
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNfrench\@ordinalstringMfrench
%    \end{macrocode}
% As above, but with initial letter in upper case. Swiss (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMfrenchswiss}[2]{%
\let\@unitstring=\@@Unitstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% French:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMfrenchfrance}[2]{%
\let\@unitstring=\@@Unitstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Belgian:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMfrenchbelgian}[2]{%
\let\@unitstring=\@@Unitstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Set default dialect:
%    \begin{macrocode}
\let\@NumberstringMfrench=\@NumberstringMfrenchfrance
%    \end{macrocode}
% As above, but feminine. Swiss:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFfrenchswiss}[2]{%
\let\@unitstring=\@@UnitstringFfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% French (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFfrenchfrance}[2]{%
\let\@unitstring=\@@UnitstringFfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Belgian (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFfrenchbelgian}[2]{%
\let\@unitstring=\@@UnitstringFfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\def\@hundred{Cent}\def\@thousand{Mille}%
\def\@andname{et}%
\@@numberstringfrench{#1}{#2}}
%    \end{macrocode}
% Set default dialect:
%    \begin{macrocode}
\let\@NumberstringFfrench=\@NumberstringFfrenchfrance
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@NumberstringNfrench\@NumberstringMfrench
%    \end{macrocode}
% Again, as from version 1.09, this has been changed to take
% two arguments, where the second argument is a control
% sequence, and nothing is displayed. Store textual representation
% of an ordinal in the given control sequence. Swiss dialect (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMfrenchswiss}[2]{%
\ifnum#1=1\relax
\def#2{premier}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrenchswiss
\let\@ninetieths=\@@ninetiethsfrenchswiss
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% French (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMfrenchfrance}[2]{%
\ifnum#1=1\relax
\def#2{premier}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrench
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@teenstringfrench
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Belgian dialect (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMfrenchbelgian}[2]{%
\ifnum#1=1\relax
\def#2{premier}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrenchswiss
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@teenstringfrench
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Set up default dialect:
%    \begin{macrocode}
\let\@ordinalstringMfrench=\@ordinalstringMfrenchfrance
%    \end{macrocode}
% As above, but feminine. Swiss:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFfrenchswiss}[2]{%
\ifnum#1=1\relax
\def#2{premi\`ere}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringFfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrenchswiss
\let\@ninetieths=\@@ninetiethsfrenchswiss
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% French (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFfrenchfrance}[2]{%
\ifnum#1=1\relax
\def#2{premi\`ere}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringFfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrench
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@teenstringfrench
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Belgian (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFfrenchbelgian}[2]{%
\ifnum#1=1\relax
\def#2{premi\`ere}%
\else
\let\@unitthstring=\@@unitthstringfrench
\let\@unitstring=\@@unitstringFfrench
\let\@teenthstring=\@@teenthstringfrench
\let\@teenstring=\@@teenstringfrench
\let\@tenthstring=\@@tenthstringfrench
\let\@tenstring=\@@tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@teenstringfrench
\def\@hundredth{centi\`eme}\def\@hundred{cent}%
\def\@thousandth{mili\`eme}\def\@thousand{mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Set up default dialect:
%    \begin{macrocode}
\let\@ordinalstringFfrench=\@ordinalstringFfrenchfrance
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNfrench\@ordinalstringMfrench
%    \end{macrocode}
% As above, but with initial letters in upper case. Swiss (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMfrenchswiss}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@Unitstringfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrenchswiss
\let\@ninetieths=\@@ninetiethsfrenchswiss
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% French (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMfrenchfrance}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@Unitstringfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrench
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@Teenstringfrench
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Belgian (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMfrenchbelgian}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@Unitstringfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@Teenstringfrench
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Set up default dialect:
%    \begin{macrocode}
\let\@OrdinalstringMfrench=\@OrdinalstringMfrenchfrance
%    \end{macrocode}
% As above, but feminine form. Swiss:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFfrenchswiss}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@UnitstringFfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrenchswiss
\let\@ninetieths=\@@ninetiethsfrenchswiss
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% French (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFfrenchfrance}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@UnitstringFfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrench
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@Teenstringfrench
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Belgian (feminine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFfrenchbelgian}[2]{%
\ifnum#1=1\relax
\def#2{Premi\`ere}%
\else
\let\@unitthstring=\@@Unitthstringfrench
\let\@unitstring=\@@UnitstringFfrench
\let\@teenthstring=\@@Teenthstringfrench
\let\@teenstring=\@@Teenstringfrench
\let\@tenthstring=\@@Tenthstringfrench
\let\@tenstring=\@@Tenstringfrench
\let\@seventieths=\@@seventiethsfrenchswiss
\let\@eightieths=\@@eightiethsfrench
\let\@ninetieths=\@@ninetiethsfrench
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\@teenstring=\@@Teenstringfrench
\def\@hundredth{Centi\`eme}\def\@hundred{Cent}%
\def\@thousandth{Mili\`eme}\def\@thousand{Mille}%
\def\@andname{et}%
\@@ordinalstringfrench{#1}{#2}%
\fi}
%    \end{macrocode}
% Set up default dialect:
%    \begin{macrocode}
\let\@OrdinalstringFfrench=\@OrdinalstringFfrenchfrance
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringNfrench\@OrdinalstringMfrench
%    \end{macrocode}
% In order to convert numbers into textual ordinals, need
% to break it up into units, tens and teens. First the units.
% The argument must be a number or count register between 0
% and 9.
%    \begin{macrocode}
\newcommand*{\@@unitthstringfrench}[1]{%
\ifcase#1\relax
zero%
\or uni\`eme%
\or deuxi\`eme%
\or troisi\`eme%
\or quatri\`eme%
\or cinqui\`eme%
\or sixi\`eme%
\or septi\`eme%
\or huiti\`eme%
\or neuvi\`eme%
\fi
}
%    \end{macrocode}
% Tens (includes Swiss and Belgian variants, special cases are
% dealt with later.)
%    \begin{macrocode}
\newcommand*{\@@tenthstringfrench}[1]{%
\ifcase#1\relax
\or dixi\`eme%
\or vingti\`eme%
\or trentri\`eme%
\or quaranti\`eme%
\or cinquanti\`eme%
\or soixanti\`eme%
\or septenti\`eme%
\or huitanti\`eme%
\or nonenti\`eme%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*{\@@teenthstringfrench}[1]{%
\ifcase#1\relax
dixi\`eme%
\or onzi\`eme%
\or douzi\`eme%
\or treizi\`eme%
\or quatorzi\`eme%
\or quinzi\`eme%
\or seizi\`eme%
\or dix-septi\`eme%
\or dix-huiti\`eme%
\or dix-neuvi\`eme%
\fi
}
%    \end{macrocode}
% Seventies vary depending on dialect. Swiss:
%    \begin{macrocode}
\newcommand*{\@@seventiethsfrenchswiss}[1]{%
\ifcase#1\relax
\@tenthstring{7}%
\or
\@tenstring{7} \@andname\ \@unitthstring{1}%
\else
\@tenstring{7}-\@unitthstring{#1}%
\fi}
%    \end{macrocode}
% Eighties vary depending on dialect. Swiss:
%    \begin{macrocode}
\newcommand*{\@@eightiethsfrenchswiss}[1]{%
\ifcase#1\relax
\@tenthstring{8}%
\or
\@tenstring{8} \@andname\ \@unitthstring{1}%
\else
\@tenstring{8}-\@unitthstring{#1}%
\fi}
%    \end{macrocode}
% Nineties vary depending on dialect. Swiss:
%    \begin{macrocode}
\newcommand*{\@@ninetiethsfrenchswiss}[1]{%
\ifcase#1\relax
\@tenthstring{9}%
\or
\@tenstring{9} \@andname\ \@unitthstring{1}%
\else
\@tenstring{9}-\@unitthstring{#1}%
\fi}
%    \end{macrocode}
% French (as spoken in France) version:
%    \begin{macrocode}
\newcommand*{\@@seventiethsfrench}[1]{%
\ifnum#1=0\relax
\@tenstring{6}%
-%
\else
\@tenstring{6}%
\ \@andname\ 
\fi
\@teenthstring{#1}%
}
%    \end{macrocode}
% Eighties (as spoken in France):
%    \begin{macrocode}
\newcommand*{\@@eightiethsfrench}[1]{%
\ifnum#1>0\relax
\@unitstring{4}-\@tenstring{2}%
-\@unitthstring{#1}%
\else
\@unitstring{4}-\@tenthstring{2}%
\fi
}
%    \end{macrocode}
% Nineties (as spoken in France):
%    \begin{macrocode}
\newcommand*{\@@ninetiethsfrench}[1]{%
\@unitstring{4}-\@tenstring{2}-\@teenthstring{#1}%
}
%    \end{macrocode}
% As above, but with initial letter in upper case. Units:
%    \begin{macrocode}
\newcommand*{\@@Unitthstringfrench}[1]{%
\ifcase#1\relax
Zero%
\or Uni\`eme%
\or Deuxi\`eme%
\or Troisi\`eme%
\or Quatri\`eme%
\or Cinqui\`eme%
\or Sixi\`eme%
\or Septi\`eme%
\or Huiti\`eme%
\or Neuvi\`eme%
\fi
}
%    \end{macrocode}
% Tens (includes Belgian and Swiss variants):
%    \begin{macrocode}
\newcommand*{\@@Tenthstringfrench}[1]{%
\ifcase#1\relax
\or Dixi\`eme%
\or Vingti\`eme%
\or Trentri\`eme%
\or Quaranti\`eme%
\or Cinquanti\`eme%
\or Soixanti\`eme%
\or Septenti\`eme%
\or Huitanti\`eme%
\or Nonenti\`eme%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*{\@@Teenthstringfrench}[1]{%
\ifcase#1\relax
Dixi\`eme%
\or Onzi\`eme%
\or Douzi\`eme%
\or Treizi\`eme%
\or Quatorzi\`eme%
\or Quinzi\`eme%
\or Seizi\`eme%
\or Dix-Septi\`eme%
\or Dix-Huiti\`eme%
\or Dix-Neuvi\`eme%
\fi
}
%    \end{macrocode}
% Store textual representation of number (first argument) in given control
% sequence (second argument).
%    \begin{macrocode}
\newcommand*{\@@numberstringfrench}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
% #1 is greater or equal to 10000
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \ifnum\@strctr>1\relax
    \ifthenelse{\(\@strctr>6\)\and\(\@strctr<10\)}{%
      \@modulo{\@tmpstrctr}{10}%
      \ifnum\@strctr<8\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@seventies{\@tmpstrctr}}%
      \else
        \ifnum\@strctr<9\relax
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@eighties{\@tmpstrctr}}%
        \else
          \ifnum\@strctr<10\relax
             \let\@@fc@numstr#2\relax
             \edef#2{\@@fc@numstr\@nineties{\@tmpstrctr}}%
          \fi
        \fi
      \fi
    }{%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
      \@strctr=#1\relax
      \divide\@strctr by 1000\relax
      \@modulo{\@strctr}{10}%
      \ifnum\@strctr>0\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
      \fi
    }%
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax 
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}\relax
  \ifnum\@tmpstrctr=100\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@hundred}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
%\@tmpstrctr=#1\relax
%\divide\@tmpstrctr by 100\relax
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \else
    \ifnum\@tmpstrctr>0\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr s}%
    \fi%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \ifthenelse{\@strctr>6}{%
    \@modulo{\@tmpstrctr}{10}%
    \ifnum\@strctr<8\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@seventies{\@tmpstrctr}}%
    \else
      \ifnum\@strctr<9\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@eighties{\@tmpstrctr}}%
      \else
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@nineties{\@tmpstrctr}}%
      \fi
    \fi
  }{%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1\relax \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@numstr#2\relax
      \ifnum\@strctr=1\relax
         \edef#2{\@@fc@numstr\ \@andname\ }%
      \else
         \edef#2{\@@fc@numstr-}%
      \fi
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  }%
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else%(>0,<10)
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else%>10
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% Store textual representation of an ordinal (from number 
% specified in first argument) in given control
% sequence (second argument).
%    \begin{macrocode}
\newcommand*{\@@ordinalstringfrench}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
% #1 is greater or equal to 10000
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \ifnum\@strctr>1\relax
    \ifthenelse{\@strctr>6}{%
      \@modulo{\@tmpstrctr}{10}%
      \ifnum\@strctr=7\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@seventies{\@tmpstrctr}}%
      \else
        \ifnum\@strctr=8\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@eighties{\@tmpstrctr}}%
        \else
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@nineties{\@tmpstrctr}}%
        \fi
      \fi
    }{%
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
      \@strctr=#1\relax
      \divide\@strctr by 1000\relax
      \@modulo{\@strctr}{10}%
      \ifnum\@strctr=1\relax
         \let\@@fc@ordstr#2\relax
         \edef#2{\@@fc@ordstr\ \@andname}%
      \fi
      \ifnum\@strctr>0\relax
         \let\@@fc@ordstr#2\relax
         \edef#2{\@@fc@ordstr\ \@unitstring{\@strctr}}%
      \fi
    }%
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@modulo{\@strctr}{1000}%
  \ifnum\@strctr=0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousandth}%
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousand}%
  \fi
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \@strctr=#1\relax \@modulo{\@strctr}{1000}%
    \ifnum\@strctr=0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\ \@thousandth}%
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\ \@thousand}%
    \fi
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{100}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@strctr=0\relax
    \edef#2{\@@fc@ordstr\ \@hundredth}%
  \else
    \edef#2{\@@fc@ordstr\ \@hundred}%
  \fi
\fi
\@tmpstrctr=\@strctr
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \@modulo{\@tmpstrctr}{10}%
  \ifthenelse{\@strctr>6}{%
    \ifnum\@strctr=7\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@seventieths{\@tmpstrctr}}%
    \else
      \ifnum\@strctr=8\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@eightieths{\@tmpstrctr}}%
      \else
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@ninetieths{\@tmpstrctr}}%
      \fi
    \fi
  }{%
    \ifnum\@tmpstrctr=0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@tenthstring{\@strctr}}%
    \else 
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
    \fi
    \@strctr=#1\relax \@modulo{\@strctr}{10}%
    \ifnum\@strctr=1\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\ \@andname}%
    \fi
    \ifnum\@strctr>0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\ \@unitthstring{\@strctr}}%
    \fi
  }%
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \else
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-french.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-german.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-german.def}
% German definitions (thank you to K. H. Fricke for supplying
% this information)
%    \begin{macrocode}
\ProvidesFile{fc-german.def}[2007/06/14]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand{\@ordinalMgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Neuter:
%    \begin{macrocode}
\newcommand{\@ordinalNgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens and teens.
% Units (argument must be a number from 0 to 9, 1 on its own (eins)
% is dealt with separately):
%    \begin{macrocode}
\newcommand{\@@unitstringgerman}[1]{%
\ifcase#1%
null%
\or ein%
\or zwei%
\or drei%
\or vier%
\or f\"unf%
\or sechs%
\or sieben%
\or acht%
\or neun%
\fi
}
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%    \begin{macrocode}
\newcommand{\@@tenstringgerman}[1]{%
\ifcase#1%
\or zehn%
\or zwanzig%
\or drei{\ss}ig%
\or vierzig%
\or f\"unfzig%
\or sechzig%
\or siebzig%
\or achtzig%
\or neunzig%
\or einhundert%
\fi
}
%    \end{macrocode}
% |\einhundert| is set to |einhundert| by default, user can
% redefine this command to just |hundert| if required, similarly
% for |\eintausend|.
%    \begin{macrocode}
\providecommand*{\einhundert}{einhundert}
\providecommand*{\eintausend}{eintausend}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenstringgerman}[1]{%
\ifcase#1%
zehn%
\or elf%
\or zw\"olf%
\or dreizehn%
\or vierzehn%
\or f\"unfzehn%
\or sechzehn%
\or siebzehn%
\or achtzehn%
\or neunzehn%
\fi
}
%    \end{macrocode}
% The results are stored in the second argument, but doesn't 
% display anything.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMgerman}[2]{%
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\@@numberstringgerman{#1}{#2}}
%    \end{macrocode}
% Feminine and neuter forms:
%    \begin{macrocode}
\let\@numberstringFgerman=\@numberstringMgerman
\let\@numberstringNgerman=\@numberstringMgerman
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMgerman}[2]{%
\@numberstringMgerman{#1}{\@@num@str}%
\edef#2{\noexpand\MakeUppercase\@@num@str}}
%    \end{macrocode}
% Feminine and neuter form:
%    \begin{macrocode}
\let\@NumberstringFgerman=\@NumberstringMgerman
\let\@NumberstringNgerman=\@NumberstringMgerman
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMgerman}[2]{%
\let\@unitthstring=\@@unitthstringMgerman
\let\@teenthstring=\@@teenthstringMgerman
\let\@tenthstring=\@@tenthstringMgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendster}%
\def\@hundredth{hundertster}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFgerman}[2]{%
\let\@unitthstring=\@@unitthstringFgerman
\let\@teenthstring=\@@teenthstringFgerman
\let\@tenthstring=\@@tenthstringFgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendste}%
\def\@hundredth{hundertste}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringNgerman}[2]{%
\let\@unitthstring=\@@unitthstringNgerman
\let\@teenthstring=\@@teenthstringNgerman
\let\@tenthstring=\@@tenthstringNgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendstes}%
\def\@hundredth{hunderstes}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMgerman}[2]{%
\@ordinalstringMgerman{#1}{\@@num@str}%
\edef#2{\protect\MakeUppercase\@@num@str}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFgerman}[2]{%
\@ordinalstringFgerman{#1}{\@@num@str}%
\edef#2{\protect\MakeUppercase\@@num@str}}
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringNgerman}[2]{%
\@ordinalstringNgerman{#1}{\@@num@str}%
\edef#2{\protect\MakeUppercase\@@num@str}}
%    \end{macrocode}
% Code for converting numbers into textual ordinals. As before,
% it is easier to split it into units, tens and teens.
% Units:
%    \begin{macrocode}
\newcommand{\@@unitthstringMgerman}[1]{%
\ifcase#1%
nullter%
\or erster%
\or zweiter%
\or dritter%
\or vierter%
\or f\"unter%
\or sechster%
\or siebter%
\or achter%
\or neunter%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@tenthstringMgerman}[1]{%
\ifcase#1%
\or zehnter%
\or zwanzigster%
\or drei{\ss}igster%
\or vierzigster%
\or f\"unfzigster%
\or sechzigster%
\or siebzigster%
\or achtzigster%
\or neunzigster%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenthstringMgerman}[1]{%
\ifcase#1%
zehnter%
\or elfter%
\or zw\"olfter%
\or dreizehnter%
\or vierzehnter%
\or f\"unfzehnter%
\or sechzehnter%
\or siebzehnter%
\or achtzehnter%
\or neunzehnter%
\fi
}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand{\@@unitthstringFgerman}[1]{%
\ifcase#1%
nullte%
\or erste%
\or zweite%
\or dritte%
\or vierte%
\or f\"unfte%
\or sechste%
\or siebte%
\or achte%
\or neunte%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand{\@@tenthstringFgerman}[1]{%
\ifcase#1%
\or zehnte%
\or zwanzigste%
\or drei{\ss}igste%
\or vierzigste%
\or f\"unfzigste%
\or sechzigste%
\or siebzigste%
\or achtzigste%
\or neunzigste%
\fi
}
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand{\@@teenthstringFgerman}[1]{%
\ifcase#1%
zehnte%
\or elfte%
\or zw\"olfte%
\or dreizehnte%
\or vierzehnte%
\or f\"unfzehnte%
\or sechzehnte%
\or siebzehnte%
\or achtzehnte%
\or neunzehnte%
\fi
}
%    \end{macrocode}
% Units (neuter):
%    \begin{macrocode}
\newcommand{\@@unitthstringNgerman}[1]{%
\ifcase#1%
nulltes%
\or erstes%
\or zweites%
\or drittes%
\or viertes%
\or f\"unte%
\or sechstes%
\or siebtes%
\or achtes%
\or neuntes%
\fi
}
%    \end{macrocode}
% Tens (neuter):
%    \begin{macrocode}
\newcommand{\@@tenthstringNgerman}[1]{%
\ifcase#1%
\or zehntes%
\or zwanzigstes%
\or drei{\ss}igstes%
\or vierzigstes%
\or f\"unfzigstes%
\or sechzigstes%
\or siebzigstes%
\or achtzigstes%
\or neunzigstes%
\fi
}
%    \end{macrocode}
% Teens (neuter)
%    \begin{macrocode}
\newcommand{\@@teenthstringNgerman}[1]{%
\ifcase#1%
zehntes%
\or elftes%
\or zw\"olftes%
\or dreizehntes%
\or vierzehntes%
\or f\"unfzehntes%
\or sechzehntes%
\or siebzehntes%
\or achtzehntes%
\or neunzehntes%
\fi
}
%    \end{macrocode}
% This appends the results to |#2| for number |#2| (in range 0 to 100.)
% null and eins are dealt with separately in |\@@numberstringgerman|.
%    \begin{macrocode}
\newcommand{\@@numberunderhundredgerman}[2]{%
\ifnum#1<10\relax
  \ifnum#1>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@unitstring{#1}}%
  \fi
\else
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@tmpstrctr}}%
  \fi
\fi
}
%    \end{macrocode}
% This stores the results in the second argument 
% (which must be a control
% sequence), but it doesn't display anything.
%    \begin{macrocode}
\newcommand{\@@numberstringgerman}[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
% #1 is >= 2000, \@strctr now contains the number of thousands
\@@numberunderhundredgerman{\@strctr}{#2}%
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr tausend}%
\else
% #1 lies in range [1000,1999]
  \ifnum\@strctr=1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\eintausend}%
  \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
% now dealing with number in range [200,999]
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@unitstring{\@strctr}hundert}%
\else
   \ifnum\@strctr=1\relax
% dealing with number in range [100,199]
     \ifnum#1>1000\relax
% if orginal number > 1000, use einhundert
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr einhundert}%
     \else
% otherwise use \einhundert
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\einhundert}%
      \fi
   \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{100}%
\ifnum#1=0\relax
  \def#2{null}%
\else
  \ifnum\@strctr=1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr eins}%
  \else
    \@@numberunderhundredgerman{\@strctr}{#2}%
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand{\@@numberunderhundredthgerman}[2]{%
\ifnum#1<10\relax
 \let\@@fc@numstr#2\relax
 \edef#2{\@@fc@numstr\@unitthstring{#1}}%
\else
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenthstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenthstring{\@tmpstrctr}}%
  \fi
\fi
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand{\@@ordinalstringgerman}[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
% #1 is >= 2000, \@strctr now contains the number of thousands
\@@numberunderhundredgerman{\@strctr}{#2}%
  \let\@@fc@numstr#2\relax
  % is that it, or is there more?
  \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=0\relax
    \edef#2{\@@fc@numstr\@thousandth}%
  \else
    \edef#2{\@@fc@numstr tausend}%
  \fi
\else
% #1 lies in range [1000,1999]
  \ifnum\@strctr=1\relax
    \ifnum#1=1000\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@thousandth}%
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\eintausend}%
    \fi
  \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
% now dealing with number in range [200,999]
  \let\@@fc@numstr#2\relax
  % is that it, or is there more?
  \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{100}%
  \ifnum\@tmpstrctr=0\relax
     \ifnum\@strctr=1\relax
       \edef#2{\@@fc@numstr\@hundredth}%
     \else
       \edef#2{\@@fc@numstr\@unitstring{\@strctr}\@hundredth}%
     \fi
  \else
     \edef#2{\@@fc@numstr\@unitstring{\@strctr}hundert}%
  \fi
\else
   \ifnum\@strctr=1\relax
% dealing with number in range [100,199]
% is that it, or is there more?
     \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{100}%
     \ifnum\@tmpstrctr=0\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@hundredth}%
     \else
     \ifnum#1>1000\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr einhundert}%
     \else
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\einhundert}%
     \fi
     \fi
   \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{100}%
\ifthenelse{\@strctr=0 \and #1>0}{}{%
\@@numberunderhundredthgerman{\@strctr}{#2}%
}%
}
%    \end{macrocode}
% Set |ngerman| to be equivalent to |german|. Is it okay to do
% this? (I don't know the difference between the two.)
%    \begin{macrocode}
\let\@ordinalMngerman=\@ordinalMgerman
\let\@ordinalFngerman=\@ordinalFgerman
\let\@ordinalNngerman=\@ordinalNgerman
\let\@numberstringMngerman=\@numberstringMgerman
\let\@numberstringFngerman=\@numberstringFgerman
\let\@numberstringNngerman=\@numberstringNgerman
\let\@NumberstringMngerman=\@NumberstringMgerman
\let\@NumberstringFngerman=\@NumberstringFgerman
\let\@NumberstringNngerman=\@NumberstringNgerman
\let\@ordinalstringMngerman=\@ordinalstringMgerman
\let\@ordinalstringFngerman=\@ordinalstringFgerman
\let\@ordinalstringNngerman=\@ordinalstringNgerman
\let\@OrdinalstringMngerman=\@OrdinalstringMgerman
\let\@OrdinalstringFngerman=\@OrdinalstringFgerman
\let\@OrdinalstringNngerman=\@OrdinalstringNgerman
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-german.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-italian.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-italian}
% Italian definitions provided by Edoardo Pasca (2008).
%    \begin{macrocode}
\ProvidesFile{fc-italian.def}[2009/10/02 Italian support for fmtcount (Edoardo Pasca)]
\newcommand{\@@unitstringitalian}[1]{%
\ifcase#1\relax
zero%
\or uno%
\or due%
\or tre%
\or quattro%
\or cinque%
\or sei%
\or sette%
\or otto%
\or nove%
\fi
}

\newcommand{\@@unitstringFitalian}[1]{%
\ifcase#1\relax
zero%
\or una%
\or doe%
\or tre%
\or quattro%
\or cinque%
\or sei%
\or sette%
\or otto%
\or nove%
\fi
}

\newcommand{\@@tenstringitalian}[1]{%
\ifcase#1\relax
\or dieci%
\or venti%
\or trenta%
\or quaranta%
\or cinquanta%
\or sessanta%
\or settanta%
\or ottanta%
\or novanta%
\or cento%
\fi
}

\newcommand{\@@teenstringitalian}[1]{%
\ifcase#1\relax
dieci%
\or undici%
\or dodici%
\or tredici%
\or quattordici%
\or quindici%
\or sedici%
\or diciassette%
\or diciotto%
\or diciannove%
\fi
}

\newcommand{\@@twentystringitalian}[1]{%
\ifcase#1\relax
venti%
\or ventuno%
\or ventidue%
\or ventitre%
\or ventiquattro%
\or venticinque%
\or ventisei%
\or ventisette%
\or ventiotto%
\or ventinove%
\fi}

\newcommand{\@@twentystringFitalian}[1]{%
\ifcase#1\relax
venti%
\or ventuna%
\or ventidue%
\or ventitre%
\or ventiquattro%
\or venticinque%
\or ventisei%
\or ventisette%
\or ventiotto%
\or ventinove%
\fi}

\newcommand{\@@hundredstringitalian}[1]{%
\ifcase#1\relax
\or cento%
\or duecento%
\or trecento%
\or quattrocento%
\or cinquecento%
\or seicento%
\or settecento%
\or ottocento%
\or novecento%
\fi}

\newcommand{\@@hundredstringFitalian}[1]{%
\ifcase#1\relax
\or cento%
\or duecento%
\or trecento%
\or quattrocento%
\or cinquecento%
\or seicento%
\or settecento%
\or ottocento%
\or novecento%
\fi}

\newcommand{\@@Unitstringitalian}[1]{%
\ifcase#1\relax
Zero%
\or Uno%
\or Due%
\or Tre%
\or Quattro%
\or Cinque%
\or Sei%
\or Sette%
\or Otto%
\or Nove%
\fi
}

\newcommand{\@@UnitstringFitalian}[1]{%
\ifcase#1\relax
Zero%
\or Una%
\or Due%
\or Tre%
\or Quattro%
\or Cinque%
\or Sei%
\or Sette%
\or Otto%
\or Nove%
\fi
}

\newcommand{\@@Tenstringitalian}[1]{%
\ifcase#1\relax
\or Dieci%
\or Venti%
\or Trenta%
\or Quaranta%
\or Cinquanta%
\or Sessanta%
\or Settanta%
\or Ottanta%
\or Novanta%
\or Cento%
\fi
}

\newcommand{\@@Teenstringitalian}[1]{%
\ifcase#1\relax
Dieci%
\or Undici%
\or Dodici%
\or Tredici%
\or Quattordici%
\or Quindici%
\or Sedici%
\or Diciassette%
\or Diciotto%
\or Diciannove%
\fi
}

\newcommand{\@@Twentystringitalian}[1]{%
\ifcase#1\relax
Venti%
\or Ventuno%
\or Ventidue%
\or Ventitre%
\or Ventiquattro%
\or Venticinque%
\or Ventisei%
\or Ventisette%
\or Ventiotto%
\or Ventinove%
\fi}

\newcommand{\@@TwentystringFitalian}[1]{%
\ifcase#1\relax
Venti%
\or Ventuno%
\or Ventidue%
\or Ventitre%
\or Ventiquattro%
\or Venticinque%
\or Ventisei%
\or Ventisette%
\or Ventiotto%
\or Ventinove%
\fi}

\newcommand{\@@Hundredstringitalian}[1]{%
\ifcase#1\relax
\or Cento%
\or Duecento%
\or Trecento%
\or Quattrocento%
\or Cinquecento%
\or Seicento%
\or Settecento%
\or Ottocento%
\or Novecento%
\fi}

\newcommand{\@@HundredstringFitalian}[1]{%
\ifcase#1\relax
\or Cento%
\or Duecento%
\or Trecento%
\or Quattrocento%
\or Cinquecento%
\or Seicento%
\or Settecento%
\or Ottocento%
\or Novecento%
\fi}


\newcommand{\@numberstringMitalian}[2]{%
\let\@unitstring=\@@unitstringitalian
\let\@teenstring=\@@teenstringitalian
\let\@tenstring=\@@tenstringitalian
\let\@twentystring=\@@twentystringitalian
\let\@hundredstring=\@@hundredstringitalian
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{y}%
\@@numberstringitalian{#1}{#2}}

\newcommand{\@numberstringFitalian}[2]{%
\let\@unitstring=\@@unitstringFitalian
\let\@teenstring=\@@teenstringitalian
\let\@tenstring=\@@tenstringitalian
\let\@twentystring=\@@twentystringFitalian
\let\@hundredstring=\@@hundredstringFitalian
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{y}%
\@@numberstringitalian{#1}{#2}}

\newcommand{\@NumberstringMitalian}[2]{%
\let\@unitstring=\@@Unitstringitalian
\let\@teenstring=\@@Teenstringitalian
\let\@tenstring=\@@Tenstringitalian
\let\@twentystring=\@@Twentystringitalian
\let\@hundredstring=\@@Hundredstringitalian
\def\@andname{y}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringitalian{#1}{#2}}

\newcommand{\@NumberstringFitalian}[2]{%
\let\@unitstring=\@@UnitstringFitalian
\let\@teenstring=\@@Teenstringitalian
\let\@tenstring=\@@Tenstringitalian
\let\@twentystring=\@@TwentystringFitalian
\let\@hundredstring=\@@HundredstringFitalian
\def\@andname{y}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringitalian{#1}{#2}}

\newcommand{\@ordinalstringMitalian}[2]{%
\let\@unitthstring=\@@unitthstringitalian
\let\@unitstring=\@@unitstringitalian
\let\@teenthstring=\@@teenthstringitalian
\let\@tenthstring=\@@tenthstringitalian
\let\@hundredthstring=\@@hundredthstringitalian
\def\@thousandth{millesimo}%
\@@ordinalstringitalian{#1}{#2}}

\newcommand{\@ordinalstringFitalian}[2]{%
\let\@unitthstring=\@@unitthstringFitalian
\let\@unitstring=\@@unitstringFitalian
\let\@teenthstring=\@@teenthstringFitalian
\let\@tenthstring=\@@tenthstringFitalian
\let\@hundredthstring=\@@hundredthstringFitalian
\def\@thousandth{millesima}%
\@@ordinalstringitalian{#1}{#2}}

\newcommand{\@OrdinalstringMitalian}[2]{%
\let\@unitthstring=\@@Unitthstringitalian
\let\@unitstring=\@@Unitstringitalian
\let\@teenthstring=\@@Teenthstringitalian
\let\@tenthstring=\@@Tenthstringitalian
\let\@hundredthstring=\@@Hundredthstringitalian
\def\@thousandth{Millesimo}%
\@@ordinalstringitalian{#1}{#2}}

\newcommand{\@OrdinalstringFitalian}[2]{%
\let\@unitthstring=\@@UnitthstringFitalian
\let\@unitstring=\@@UnitstringFitalian
\let\@teenthstring=\@@TeenthstringFitalian
\let\@tenthstring=\@@TenthstringFitalian
\let\@hundredthstring=\@@HundredthstringFitalian
\def\@thousandth{Millesima}%
\@@ordinalstringitalian{#1}{#2}}

\newcommand{\@ordinalMitalian}[2]{\edef#2{#1\relax\noexpand\fmtord{o}}}
\newcommand{\@ordinalFitalian}[2]{\edef#2{#1\relax\noexpand\fmtord{a}}}

\newcommand{\@@unitthstringitalian}[1]{%
\ifcase#1\relax
zero%
\or primo%
\or secondo%
\or terzo%
\or quarto%
\or quinto%
\or sesto%
\or settimo%
\or ottavo%
\or nono%
\fi
}

\newcommand{\@@tenthstringitalian}[1]{%
\ifcase#1\relax
\or decimo%
\or ventesimo%
\or trentesimo%
\or quarantesimo%
\or cinquantesimo%
\or sessantesimo%
\or settantesimo%
\or ottantesimo%
\or novantesimo%
\fi
}

\newcommand{\@@teenthstringitalian}[1]{%
\ifcase#1\relax
decimo%
\or undicesimo%
\or dodicesimo%
\or tredicesimo%
\or quattordicesimo%
\or quindicesimo%
\or sedicesimo%
\or diciassettesimo%
\or diciottesimo%
\or diciannovesimo%
\fi
}

\newcommand{\@@hundredthstringitalian}[1]{%
\ifcase#1\relax
\or centesimo%
\or duecentesimo%
\or trecentesimo%
\or quattrocentesimo%
\or cinquecentesimo%
\or seicentesimo%
\or settecentesimo%
\or ottocentesimo%
\or novecentesimo%
\fi}

\newcommand{\@@unitthstringFitalian}[1]{%
\ifcase#1\relax
zero%
\or prima%
\or seconda%
\or terza%
\or quarta%
\or quinta%
\or sesta%
\or settima%
\or ottava%
\or nona%
\fi
}

\newcommand{\@@tenthstringFitalian}[1]{%
\ifcase#1\relax
\or decima%
\or ventesima%
\or trentesima%
\or quarantesima%
\or cinquantesima%
\or sessantesima%
\or settantesima%
\or ottantesima%
\or novantesima%
\fi
}

\newcommand{\@@teenthstringFitalian}[1]{%
\ifcase#1\relax
decima%
\or undicesima%
\or dodicesima%
\or tredicesima%
\or quattordicesima%
\or quindicesima%
\or sedicesima%
\or diciassettesima%
\or diciottesima%
\or diciannovesima%
\fi
}

\newcommand{\@@hundredthstringFitalian}[1]{%
\ifcase#1\relax
\or centesima%
\or duecentesima%
\or trecentesima%
\or quattrocentesima%
\or cinquecentesima%
\or seicentesima%
\or settecentesima%
\or ottocentesima%
\or novecentesima%
\fi}

\newcommand{\@@Unitthstringitalian}[1]{%
\ifcase#1\relax
Zero%
\or Primo%
\or Secondo%
\or Terzo%
\or Quarto%
\or Quinto%
\or Sesto%
\or Settimo%
\or Ottavo%
\or Nono%
\fi
}

\newcommand{\@@Tenthstringitalian}[1]{%
\ifcase#1\relax
\or Decimo%
\or Ventesimo%
\or Trentesimo%
\or Quarantesimo%
\or Cinquantesimo%
\or Sessantesimo%
\or Settantesimo%
\or Ottantesimo%
\or Novantesimo%
\fi
}

\newcommand{\@@Teenthstringitalian}[1]{%
\ifcase#1\relax
Decimo%
\or Undicesimo%
\or Dodicesimo%
\or Tredicesimo%
\or Quattordicesimo%
\or Quindicesimo%
\or Sedicesimo%
\or Diciassettesimo%
\or Diciottesimo%
\or Diciannovesimo%
\fi
}

\newcommand{\@@Hundredthstringitalian}[1]{%
\ifcase#1\relax
\or Centesimo%
\or Duecentesimo%
\or Trecentesimo%
\or Quattrocentesimo%
\or Cinquecentesimo%
\or Seicentesimo%
\or Settecentesimo%
\or Ottocentesimo%
\or Novecentesimo%
\fi}

\newcommand{\@@UnitthstringFitalian}[1]{%
\ifcase#1\relax
Zero%
\or Prima%
\or Seconda%
\or Terza%
\or Quarta%
\or Quinta%
\or Sesta%
\or Settima%
\or Ottava%
\or Nona%
\fi
}

\newcommand{\@@TenthstringFitalian}[1]{%
\ifcase#1\relax
\or Decima%
\or Ventesima%
\or Trentesima%
\or Quarantesima%
\or Cinquantesima%
\or Sessantesima%
\or Settantesima%
\or Ottantesima%
\or Novantesima%
\fi
}

\newcommand{\@@TeenthstringFitalian}[1]{%
\ifcase#1\relax
Decima%
\or Undicesima%
\or Dodicesima%
\or Tredicesima%
\or Quattordicesima%
\or Quindicesima%
\or Sedicesima%
\or Diciassettesima%
\or Diciottesima%
\or Diciannovesima%
\fi
}

\newcommand{\@@HundredthstringFitalian}[1]{%
\ifcase#1\relax
\or Centesima%
\or Duecentesima%
\or Trecentesima%
\or Quattrocentesima%
\or Cinquecentesima%
\or Seicentesima%
\or Settecentesima%
\or Ottocentesima%
\or Novecentesima%
\fi}


\newcommand{\@@numberstringitalian}[2]{%
\def#2{}%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
  \divide\@strctr by 10\relax
  \ifnum\@strctr>1\relax
    \edef#2{\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}%
  \let\@@fc@numstr#2\relax
  \ifnum\@tmpstrctr=100\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
   \ifnum\@strctr>0\relax
     \let\@@fc@numstr#2\relax
     \edef#2{\@@fc@numstr\ \@andname\ }%
   \fi
\fi
\ifnum\@strctr>29\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
         \let\@@fc@numstr#2\relax
         \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \ifnum\@strctr>19\relax
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@twentystring{\@strctr}}%
    \else
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
    \fi
  \fi
\fi
}

\newcommand{\@@ordinalstringitalian}[2]{%
\@strctr=#1\relax
\def#2{}%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \else
    \ifnum\@strctr>999\relax
      \divide\@strctr by 1000\relax
      \ifnum\@strctr>1\relax
        \ifnum\@strctr>9\relax
          \@tmpstrctr=\@strctr
          \ifnum\@strctr<20\relax
            \@modulo{\@tmpstrctr}{10}%
            \let\@@fc@numstr#2\relax
            \edef#2{\@@fc@numstr\@teenthstring{\@tmpstrctr} }%
          \else
            \divide\@tmpstrctr by 10\relax
            \let\@@fc@numstr#2\relax
            \edef#2{\@@fc@numstr\@tenthstring{\@tmpstrctr} }%
            \@tmpstrctr=\@strctr
            \@modulo{\@tmpstrctr}{10}%
            \ifnum\@tmpstrctr>0\relax
              \let\@@fc@numstr#2\relax
              \edef#2{\@@fc@numstr\@unitthstring{\@tmpstrctr} }%
            \fi
          \fi
        \else
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@unitstring{\@strctr} }%
        \fi
      \fi
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@thousandth}%
    \fi
    \@strctr=#1\relax
    \@modulo{\@strctr}{1000}%
    \ifnum\@strctr>99\relax
      \@tmpstrctr=\@strctr
      \divide\@tmpstrctr by 100\relax
      \ifnum#1>1000\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ }%
      \fi
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@hundredthstring{\@tmpstrctr}}%
    \fi
    \@modulo{\@strctr}{100}%
    \ifnum#1>99\relax
      \ifnum\@strctr>0\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ }%
      \fi
    \fi
    \ifnum\@strctr>19\relax
      \@tmpstrctr=\@strctr
      \divide\@tmpstrctr by 10\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@tenthstring{\@tmpstrctr}}%
      \@tmpstrctr=\@strctr
      \@modulo{\@tmpstrctr}{10}%
      \ifnum\@tmpstrctr>0\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@unitthstring{\@tmpstrctr}}%
      \fi
    \else
      \ifnum\@strctr>9\relax
        \@modulo{\@strctr}{10}%
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@teenthstring{\@strctr}}%
      \else
        \ifnum\@strctr=0\relax
          \ifnum#1=0\relax
            \let\@@fc@numstr#2\relax
            \edef#2{\@@fc@numstr\@unitstring{0}}%
          \fi
        \else
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@unitthstring{\@strctr}}%
        \fi
      \fi
    \fi
  \fi
\fi
}
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-italian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-portuges.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-portuges.def}
% Portuguse definitions
%    \begin{macrocode}
\ProvidesFile{fc-portuges.def}[2007/05/26]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the second
% argument, which should be a control sequence. Masculine:
%    \begin{macrocode}
\newcommand*{\@ordinalMportuges}[2]{%
\ifnum#1=0\relax
  \edef#2{\number#1}%
\else
  \edef#2{\number#1\relax\noexpand\fmtord{o}}%
\fi}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand*{\@ordinalFportuges}[2]{%
\ifnum#1=0\relax
  \edef#2{\number#1}%
\else
  \edef#2{\number#1\relax\noexpand\fmtord{a}}%
\fi}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalNportuges\@ordinalMportuges
%    \end{macrocode}
% Convert a number to a textual representation. To make it easier,
% split it up into units, tens, teens and hundreds. Units (argument must
% be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*{\@@unitstringportuges}[1]{%
\ifcase#1\relax
zero%
\or um%
\or dois%
\or tr\^es%
\or quatro%
\or cinco%
\or seis%
\or sete%
\or oito%
\or nove%
\fi
}
%   \end{macrocode}
% As above, but for feminine:
%   \begin{macrocode}
\newcommand*{\@@unitstringFportuges}[1]{%
\ifcase#1\relax
zero%
\or uma%
\or duas%
\or tr\^es%
\or quatro%
\or cinco%
\or seis%
\or sete%
\or oito%
\or nove%
\fi
}
%    \end{macrocode}
% Tens (argument must be a number from 0 to 10):
%    \begin{macrocode}
\newcommand*{\@@tenstringportuges}[1]{%
\ifcase#1\relax
\or dez%
\or vinte%
\or trinta%
\or quarenta%
\or cinq\"uenta%
\or sessenta%
\or setenta%
\or oitenta%
\or noventa%
\or cem%
\fi
}
%    \end{macrocode}
% Teens (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*{\@@teenstringportuges}[1]{%
\ifcase#1\relax
dez%
\or onze%
\or doze%
\or treze%
\or quatorze%
\or quinze%
\or dezesseis%
\or dezessete%
\or dezoito%
\or dezenove%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@hundredstringportuges}[1]{%
\ifcase#1\relax
\or cento%
\or duzentos%
\or trezentos%
\or quatrocentos%
\or quinhentos%
\or seiscentos%
\or setecentos%
\or oitocentos%
\or novecentos%
\fi}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@hundredstringFportuges}[1]{%
\ifcase#1\relax
\or cento%
\or duzentas%
\or trezentas%
\or quatrocentas%
\or quinhentas%
\or seiscentas%
\or setecentas%
\or oitocentas%
\or novecentas%
\fi}
%    \end{macrocode}
% Units (initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Unitstringportuges}[1]{%
\ifcase#1\relax
Zero%
\or Um%
\or Dois%
\or Tr\^es%
\or Quatro%
\or Cinco%
\or Seis%
\or Sete%
\or Oito%
\or Nove%
\fi
}
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*{\@@UnitstringFportuges}[1]{%
\ifcase#1\relax
Zera%
\or Uma%
\or Duas%
\or Tr\^es%
\or Quatro%
\or Cinco%
\or Seis%
\or Sete%
\or Oito%
\or Nove%
\fi
}
%    \end{macrocode}
% Tens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Tenstringportuges}[1]{%
\ifcase#1\relax
\or Dez%
\or Vinte%
\or Trinta%
\or Quarenta%
\or Cinq\"uenta%
\or Sessenta%
\or Setenta%
\or Oitenta%
\or Noventa%
\or Cem%
\fi
}
%    \end{macrocode}
% Teens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Teenstringportuges}[1]{%
\ifcase#1\relax
Dez%
\or Onze%
\or Doze%
\or Treze%
\or Quatorze%
\or Quinze%
\or Dezesseis%
\or Dezessete%
\or Dezoito%
\or Dezenove%
\fi
}
%    \end{macrocode}
% Hundreds (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Hundredstringportuges}[1]{%
\ifcase#1\relax
\or Cento%
\or Duzentos%
\or Trezentos%
\or Quatrocentos%
\or Quinhentos%
\or Seiscentos%
\or Setecentos%
\or Oitocentos%
\or Novecentos%
\fi}
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*{\@@HundredstringFportuges}[1]{%
\ifcase#1\relax
\or Cento%
\or Duzentas%
\or Trezentas%
\or Quatrocentas%
\or Quinhentas%
\or Seiscentas%
\or Setecentas%
\or Oitocentas%
\or Novecentas%
\fi}
%    \end{macrocode}
% This has changed in version 1.08, so that it now stores
% the result in the second argument, but doesn't display
% anything. Since it only affects internal macros, it shouldn't
% affect documents created with older versions. (These internal
% macros are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMportuges}[2]{%
\let\@unitstring=\@@unitstringportuges
\let\@teenstring=\@@teenstringportuges
\let\@tenstring=\@@tenstringportuges
\let\@hundredstring=\@@hundredstringportuges
\def\@hundred{cem}\def\@thousand{mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFportuges}[2]{%
\let\@unitstring=\@@unitstringFportuges
\let\@teenstring=\@@teenstringportuges
\let\@tenstring=\@@tenstringportuges
\let\@hundredstring=\@@hundredstringFportuges
\def\@hundred{cem}\def\@thousand{mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@numberstringNportuges\@numberstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMportuges}[2]{%
\let\@unitstring=\@@Unitstringportuges
\let\@teenstring=\@@Teenstringportuges
\let\@tenstring=\@@Tenstringportuges
\let\@hundredstring=\@@Hundredstringportuges
\def\@hundred{Cem}\def\@thousand{Mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFportuges}[2]{%
\let\@unitstring=\@@UnitstringFportuges
\let\@teenstring=\@@Teenstringportuges
\let\@tenstring=\@@Tenstringportuges
\let\@hundredstring=\@@HundredstringFportuges
\def\@hundred{Cem}\def\@thousand{Mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@NumberstringNportuges\@NumberstringMportuges
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMportuges}[2]{%
\let\@unitthstring=\@@unitthstringportuges
\let\@unitstring=\@@unitstringportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@tenthstringportuges
\let\@hundredthstring=\@@hundredthstringportuges
\def\@thousandth{mil\'esimo}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFportuges}[2]{%
\let\@unitthstring=\@@unitthstringFportuges
\let\@unitstring=\@@unitstringFportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@tenthstringFportuges
\let\@hundredthstring=\@@hundredthstringFportuges
\def\@thousandth{mil\'esima}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNportuges\@ordinalstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMportuges}[2]{%
\let\@unitthstring=\@@Unitthstringportuges
\let\@unitstring=\@@Unitstringportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@Tenthstringportuges
\let\@hundredthstring=\@@Hundredthstringportuges
\def\@thousandth{Mil\'esimo}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFportuges}[2]{%
\let\@unitthstring=\@@UnitthstringFportuges
\let\@unitstring=\@@UnitstringFportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@TenthstringFportuges
\let\@hundredthstring=\@@HundredthstringFportuges
\def\@thousandth{Mil\'esima}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringNportuges\@OrdinalstringMportuges
%    \end{macrocode}
% In order to do the ordinals, split into units, teens, tens
% and hundreds. Units:
%    \begin{macrocode}
\newcommand*{\@@unitthstringportuges}[1]{%
\ifcase#1\relax
zero%
\or primeiro%
\or segundo%
\or terceiro%
\or quarto%
\or quinto%
\or sexto%
\or s\'etimo%
\or oitavo%
\or nono%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*{\@@tenthstringportuges}[1]{%
\ifcase#1\relax
\or d\'ecimo%
\or vig\'esimo%
\or trig\'esimo%
\or quadrag\'esimo%
\or q\"uinquag\'esimo%
\or sexag\'esimo%
\or setuag\'esimo%
\or octog\'esimo%
\or nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*{\@@teenthstringportuges}[1]{%
\@tenthstring{1}%
\ifnum#1>0\relax
-\@unitthstring{#1}%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@hundredthstringportuges}[1]{%
\ifcase#1\relax
\or cent\'esimo%
\or ducent\'esimo%
\or trecent\'esimo%
\or quadringent\'esimo%
\or q\"uingent\'esimo%
\or seiscent\'esimo%
\or setingent\'esimo%
\or octingent\'esimo%
\or nongent\'esimo%
\fi}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand*{\@@unitthstringFportuges}[1]{%
\ifcase#1\relax
zero%
\or primeira%
\or segunda%
\or terceira%
\or quarta%
\or quinta%
\or sexta%
\or s\'etima%
\or oitava%
\or nona%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand*{\@@tenthstringFportuges}[1]{%
\ifcase#1\relax
\or d\'ecima%
\or vig\'esima%
\or trig\'esima%
\or quadrag\'esima%
\or q\"uinquag\'esima%
\or sexag\'esima%
\or setuag\'esima%
\or octog\'esima%
\or nonag\'esima%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@hundredthstringFportuges}[1]{%
\ifcase#1\relax
\or cent\'esima%
\or ducent\'esima%
\or trecent\'esima%
\or quadringent\'esima%
\or q\"uingent\'esima%
\or seiscent\'esima%
\or setingent\'esima%
\or octingent\'esima%
\or nongent\'esima%
\fi}
%    \end{macrocode}
% As above, but with initial letter in upper case. Units:
%    \begin{macrocode}
\newcommand*{\@@Unitthstringportuges}[1]{%
\ifcase#1\relax
Zero%
\or Primeiro%
\or Segundo%
\or Terceiro%
\or Quarto%
\or Quinto%
\or Sexto%
\or S\'etimo%
\or Oitavo%
\or Nono%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*{\@@Tenthstringportuges}[1]{%
\ifcase#1\relax
\or D\'ecimo%
\or Vig\'esimo%
\or Trig\'esimo%
\or Quadrag\'esimo%
\or Q\"uinquag\'esimo%
\or Sexag\'esimo%
\or Setuag\'esimo%
\or Octog\'esimo%
\or Nonag\'esimo%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@Hundredthstringportuges}[1]{%
\ifcase#1\relax
\or Cent\'esimo%
\or Ducent\'esimo%
\or Trecent\'esimo%
\or Quadringent\'esimo%
\or Q\"uingent\'esimo%
\or Seiscent\'esimo%
\or Setingent\'esimo%
\or Octingent\'esimo%
\or Nongent\'esimo%
\fi}
%    \end{macrocode}
% As above, but feminine. Units:
%    \begin{macrocode}
\newcommand*{\@@UnitthstringFportuges}[1]{%
\ifcase#1\relax
Zera%
\or Primeira%
\or Segunda%
\or Terceira%
\or Quarta%
\or Quinta%
\or Sexta%
\or S\'etima%
\or Oitava%
\or Nona%
\fi
}
%    \end{macrocode}
% Tens (feminine);
%    \begin{macrocode}
\newcommand*{\@@TenthstringFportuges}[1]{%
\ifcase#1\relax
\or D\'ecima%
\or Vig\'esima%
\or Trig\'esima%
\or Quadrag\'esima%
\or Q\"uinquag\'esima%
\or Sexag\'esima%
\or Setuag\'esima%
\or Octog\'esima%
\or Nonag\'esima%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@HundredthstringFportuges}[1]{%
\ifcase#1\relax
\or Cent\'esima%
\or Ducent\'esima%
\or Trecent\'esima%
\or Quadringent\'esima%
\or Q\"uingent\'esima%
\or Seiscent\'esima%
\or Setingent\'esima%
\or Octingent\'esima%
\or Nongent\'esima%
\fi}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument (a control sequence), but it
% doesn't display anything. Since it only affects internal macros,
% it shouldn't affect documents created with older versions.
% (These internal macros are not meant for use in documents.)
%    \begin{macrocode}
\newcommand*{\@@numberstringportuges}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
% #1 is greater or equal to 10000
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0
      \ifnum\@strctr=1\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@andname}%
      \fi
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax 
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000 \relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}%
  \let\@@fc@numstr#2\relax
  \ifnum\@tmpstrctr=100\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi%
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0
    \ifnum\@strctr=1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ \@andname}%
    \else
      \ifnum#1>100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@andname}%
      \fi
    \fi 
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else%(>0,<10)
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else%>10
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\newcommand*{\@@ordinalstringportuges}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@modulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@modulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-}%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@modulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-}%
  \fi
\fi
\ifnum\@strctr>9\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@modulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-\@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr=0\relax
    \ifnum#1=0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitstring{0}}%
    \fi
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
  \fi
\fi
\fi
\fi
}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-portuges.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-spanish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-spanish.def}
% Spanish definitions
%    \begin{macrocode}
\ProvidesFile{fc-spanish.def}[2007/05/26]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand{\@ordinalMspanish}[2]{%
\edef#2{\number#1\relax\noexpand\fmtord{o}}}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFspanish}[2]{%
\edef#2{\number#1\relax\noexpand\fmtord{a}}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalNspanish\@ordinalMspanish
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens, teens, twenties and hundreds.
% Units (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand{\@@unitstringspanish}[1]{%
\ifcase#1\relax
cero%
\or uno%
\or dos%
\or tres%
\or cuatro%
\or cinco%
\or seis%
\or siete%
\or ocho%
\or nueve%
\fi
}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@@unitstringFspanish}[1]{%
\ifcase#1\relax
cera%
\or una%
\or dos%
\or tres%
\or cuatro%
\or cinco%
\or seis%
\or siete%
\or ocho%
\or nueve%
\fi
}
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%    \begin{macrocode}
\newcommand{\@@tenstringspanish}[1]{%
\ifcase#1\relax
\or diez%
\or viente%
\or treinta%
\or cuarenta%
\or cincuenta%
\or sesenta%
\or setenta%
\or ochenta%
\or noventa%
\or cien%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenstringspanish}[1]{%
\ifcase#1\relax
diez%
\or once%
\or doce%
\or trece%
\or catorce%
\or quince%
\or diecis\'eis%
\or diecisiete%
\or dieciocho%
\or diecinueve%
\fi
}
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand{\@@twentystringspanish}[1]{%
\ifcase#1\relax
veinte%
\or veintiuno%
\or veintid\'os%
\or veintitr\'es%
\or veinticuatro%
\or veinticinco%
\or veintis\'eis%
\or veintisiete%
\or veintiocho%
\or veintinueve%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@twentystringFspanish}[1]{%
\ifcase#1\relax
veinte%
\or veintiuna%
\or veintid\'os%
\or veintitr\'es%
\or veinticuatro%
\or veinticinco%
\or veintis\'eis%
\or veintisiete%
\or veintiocho%
\or veintinueve%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@hundredstringspanish}[1]{%
\ifcase#1\relax
\or ciento%
\or doscientos%
\or trescientos%
\or cuatrocientos%
\or quinientos%
\or seiscientos%
\or setecientos%
\or ochocientos%
\or novecientos%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@hundredstringFspanish}[1]{%
\ifcase#1\relax
\or cienta%
\or doscientas%
\or trescientas%
\or cuatrocientas%
\or quinientas%
\or seiscientas%
\or setecientas%
\or ochocientas%
\or novecientas%
\fi}
%    \end{macrocode}
% As above, but with initial letter uppercase:
%    \begin{macrocode}
\newcommand{\@@Unitstringspanish}[1]{%
\ifcase#1\relax
Cero%
\or Uno%
\or Dos%
\or Tres%
\or Cuatro%
\or Cinco%
\or Seis%
\or Siete%
\or Ocho%
\or Nueve%
\fi
}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@UnitstringFspanish}[1]{%
\ifcase#1\relax
Cera%
\or Una%
\or Dos%
\or Tres%
\or Cuatro%
\or Cinco%
\or Seis%
\or Siete%
\or Ocho%
\or Nueve%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@Tenstringspanish}[1]{%
\ifcase#1\relax
\or Diez%
\or Viente%
\or Treinta%
\or Cuarenta%
\or Cincuenta%
\or Sesenta%
\or Setenta%
\or Ochenta%
\or Noventa%
\or Cien%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@Teenstringspanish}[1]{%
\ifcase#1\relax
Diez%
\or Once%
\or Doce%
\or Trece%
\or Catorce%
\or Quince%
\or Diecis\'eis%
\or Diecisiete%
\or Dieciocho%
\or Diecinueve%
\fi
}
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand{\@@Twentystringspanish}[1]{%
\ifcase#1\relax
Veinte%
\or Veintiuno%
\or Veintid\'os%
\or Veintitr\'es%
\or Veinticuatro%
\or Veinticinco%
\or Veintis\'eis%
\or Veintisiete%
\or Veintiocho%
\or Veintinueve%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@TwentystringFspanish}[1]{%
\ifcase#1\relax
Veinte%
\or Veintiuna%
\or Veintid\'os%
\or Veintitr\'es%
\or Veinticuatro%
\or Veinticinco%
\or Veintis\'eis%
\or Veintisiete%
\or Veintiocho%
\or Veintinueve%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@Hundredstringspanish}[1]{%
\ifcase#1\relax
\or Ciento%
\or Doscientos%
\or Trescientos%
\or Cuatrocientos%
\or Quinientos%
\or Seiscientos%
\or Setecientos%
\or Ochocientos%
\or Novecientos%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@HundredstringFspanish}[1]{%
\ifcase#1\relax
\or Cienta%
\or Doscientas%
\or Trescientas%
\or Cuatrocientas%
\or Quinientas%
\or Seiscientas%
\or Setecientas%
\or Ochocientas%
\or Novecientas%
\fi}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros
% are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMspanish}[2]{%
\let\@unitstring=\@@unitstringspanish
\let\@teenstring=\@@teenstringspanish
\let\@tenstring=\@@tenstringspanish
\let\@twentystring=\@@twentystringspanish
\let\@hundredstring=\@@hundredstringspanish
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{y}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFspanish}[2]{%
\let\@unitstring=\@@unitstringFspanish
\let\@teenstring=\@@teenstringspanish
\let\@tenstring=\@@tenstringspanish
\let\@twentystring=\@@twentystringFspanish
\let\@hundredstring=\@@hundredstringFspanish
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{y}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@numberstringNspanish\@numberstringMspanish
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMspanish}[2]{%
\let\@unitstring=\@@Unitstringspanish
\let\@teenstring=\@@Teenstringspanish
\let\@tenstring=\@@Tenstringspanish
\let\@twentystring=\@@Twentystringspanish
\let\@hundredstring=\@@Hundredstringspanish
\def\@andname{y}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFspanish}[2]{%
\let\@unitstring=\@@UnitstringFspanish
\let\@teenstring=\@@Teenstringspanish
\let\@tenstring=\@@Tenstringspanish
\let\@twentystring=\@@TwentystringFspanish
\let\@hundredstring=\@@HundredstringFspanish
\def\@andname{y}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@NumberstringNspanish\@NumberstringMspanish
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMspanish}[2]{%
\let\@unitthstring=\@@unitthstringspanish
\let\@unitstring=\@@unitstringspanish
\let\@teenthstring=\@@teenthstringspanish
\let\@tenthstring=\@@tenthstringspanish
\let\@hundredthstring=\@@hundredthstringspanish
\def\@thousandth{mil\'esimo}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFspanish}[2]{%
\let\@unitthstring=\@@unitthstringFspanish
\let\@unitstring=\@@unitstringFspanish
\let\@teenthstring=\@@teenthstringFspanish
\let\@tenthstring=\@@tenthstringFspanish
\let\@hundredthstring=\@@hundredthstringFspanish
\def\@thousandth{mil\'esima}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNspanish\@ordinalstringMspanish
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMspanish}[2]{%
\let\@unitthstring=\@@Unitthstringspanish
\let\@unitstring=\@@Unitstringspanish
\let\@teenthstring=\@@Teenthstringspanish
\let\@tenthstring=\@@Tenthstringspanish
\let\@hundredthstring=\@@Hundredthstringspanish
\def\@thousandth{Mil\'esimo}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFspanish}[2]{%
\let\@unitthstring=\@@UnitthstringFspanish
\let\@unitstring=\@@UnitstringFspanish
\let\@teenthstring=\@@TeenthstringFspanish
\let\@tenthstring=\@@TenthstringFspanish
\let\@hundredthstring=\@@HundredthstringFspanish
\def\@thousandth{Mil\'esima}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringNspanish\@OrdinalstringMspanish
%    \end{macrocode}
% Code for convert numbers into textual ordinals. As before,
% it is easier to split it into units, tens, teens and hundreds.
% Units:
%    \begin{macrocode}
\newcommand{\@@unitthstringspanish}[1]{%
\ifcase#1\relax
cero%
\or primero%
\or segundo%
\or tercero%
\or cuarto%
\or quinto%
\or sexto%
\or s\'eptimo%
\or octavo%
\or noveno%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@tenthstringspanish}[1]{%
\ifcase#1\relax
\or d\'ecimo%
\or vig\'esimo%
\or trig\'esimo%
\or cuadrag\'esimo%
\or quincuag\'esimo%
\or sexag\'esimo%
\or septuag\'esimo%
\or octog\'esimo%
\or nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenthstringspanish}[1]{%
\ifcase#1\relax
d\'ecimo%
\or und\'ecimo%
\or duod\'ecimo%
\or decimotercero%
\or decimocuarto%
\or decimoquinto%
\or decimosexto%
\or decimos\'eptimo%
\or decimoctavo%
\or decimonoveno%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@hundredthstringspanish}[1]{%
\ifcase#1\relax
\or cent\'esimo%
\or ducent\'esimo%
\or tricent\'esimo%
\or cuadringent\'esimo%
\or quingent\'esimo%
\or sexcent\'esimo%
\or septing\'esimo%
\or octingent\'esimo%
\or noningent\'esimo%
\fi}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand{\@@unitthstringFspanish}[1]{%
\ifcase#1\relax
cera%
\or primera%
\or segunda%
\or tercera%
\or cuarta%
\or quinta%
\or sexta%
\or s\'eptima%
\or octava%
\or novena%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand{\@@tenthstringFspanish}[1]{%
\ifcase#1\relax
\or d\'ecima%
\or vig\'esima%
\or trig\'esima%
\or cuadrag\'esima%
\or quincuag\'esima%
\or sexag\'esima%
\or septuag\'esima%
\or octog\'esima%
\or nonag\'esima%
\fi
}
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand{\@@teenthstringFspanish}[1]{%
\ifcase#1\relax
d\'ecima%
\or und\'ecima%
\or duod\'ecima%
\or decimotercera%
\or decimocuarta%
\or decimoquinta%
\or decimosexta%
\or decimos\'eptima%
\or decimoctava%
\or decimonovena%
\fi
}
%    \end{macrocode}
% Hundreds (feminine)
%    \begin{macrocode}
\newcommand{\@@hundredthstringFspanish}[1]{%
\ifcase#1\relax
\or cent\'esima%
\or ducent\'esima%
\or tricent\'esima%
\or cuadringent\'esima%
\or quingent\'esima%
\or sexcent\'esima%
\or septing\'esima%
\or octingent\'esima%
\or noningent\'esima%
\fi}
%    \end{macrocode}
% As above, but with initial letters in upper case
%    \begin{macrocode}
\newcommand{\@@Unitthstringspanish}[1]{%
\ifcase#1\relax
Cero%
\or Primero%
\or Segundo%
\or Tercero%
\or Cuarto%
\or Quinto%
\or Sexto%
\or S\'eptimo%
\or Octavo%
\or Noveno%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@Tenthstringspanish}[1]{%
\ifcase#1\relax
\or D\'ecimo%
\or Vig\'esimo%
\or Trig\'esimo%
\or Cuadrag\'esimo%
\or Quincuag\'esimo%
\or Sexag\'esimo%
\or Septuag\'esimo%
\or Octog\'esimo%
\or Nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@Teenthstringspanish}[1]{%
\ifcase#1\relax
D\'ecimo%
\or Und\'ecimo%
\or Duod\'ecimo%
\or Decimotercero%
\or Decimocuarto%
\or Decimoquinto%
\or Decimosexto%
\or Decimos\'eptimo%
\or Decimoctavo%
\or Decimonoveno%
\fi
}
%    \end{macrocode}
% Hundreds
%    \begin{macrocode}
\newcommand{\@@Hundredthstringspanish}[1]{%
\ifcase#1\relax
\or Cent\'esimo%
\or Ducent\'esimo%
\or Tricent\'esimo%
\or Cuadringent\'esimo%
\or Quingent\'esimo%
\or Sexcent\'esimo%
\or Septing\'esimo%
\or Octingent\'esimo%
\or Noningent\'esimo%
\fi}
%    \end{macrocode}
% As above, but feminine.
%    \begin{macrocode}
\newcommand{\@@UnitthstringFspanish}[1]{%
\ifcase#1\relax
Cera%
\or Primera%
\or Segunda%
\or Tercera%
\or Cuarta%
\or Quinta%
\or Sexta%
\or S\'eptima%
\or Octava%
\or Novena%
\fi
}
%    \end{macrocode}
% Tens (feminine)
%    \begin{macrocode}
\newcommand{\@@TenthstringFspanish}[1]{%
\ifcase#1\relax
\or D\'ecima%
\or Vig\'esima%
\or Trig\'esima%
\or Cuadrag\'esima%
\or Quincuag\'esima%
\or Sexag\'esima%
\or Septuag\'esima%
\or Octog\'esima%
\or Nonag\'esima%
\fi
}
%    \end{macrocode}
% Teens (feminine):
%    \begin{macrocode}
\newcommand{\@@TeenthstringFspanish}[1]{%
\ifcase#1\relax
D\'ecima%
\or Und\'ecima%
\or Duod\'ecima%
\or Decimotercera%
\or Decimocuarta%
\or Decimoquinta%
\or Decimosexta%
\or Decimos\'eptima%
\or Decimoctava%
\or Decimonovena%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand{\@@HundredthstringFspanish}[1]{%
\ifcase#1\relax
\or Cent\'esima%
\or Ducent\'esima%
\or Tricent\'esima%
\or Cuadringent\'esima%
\or Quingent\'esima%
\or Sexcent\'esima%
\or Septing\'esima%
\or Octingent\'esima%
\or Noningent\'esima%
\fi}

%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% results in the second argument (which must be a control
% sequence), but it doesn't display anything. Since it only
% affects internal macros, it shouldn't affect documnets created
% with older versions. (These internal macros are not meant for
% use in documents.)
%    \begin{macrocode}
\newcommand{\@@numberstringspanish}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
% #1 is greater or equal to 10000
  \divide\@strctr by 10
  \ifnum\@strctr>1
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax 
    \ifnum\@strctr>1\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=100\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>29\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \ifnum\@strctr>19\relax
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@twentystring{\@strctr}}%
    \else
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
    \fi
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand{\@@ordinalstringspanish}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@modulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@modulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
       \let\@@fc@ordstr#2\relax
       \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@modulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@modulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr>9\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \else
    \ifnum\@strctr=0\relax
      \ifnum#1=0\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitstring{0}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \fi
\fi
\fi
\fi
}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-spanish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-UKenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-UKenglish.def}
% UK English definitions
%    \begin{macrocode}
\ProvidesFile{fc-UKenglish}[2007/06/14]
%    \end{macrocode}
% Check that fc-english.def has been loaded
%    \begin{macrocode}
\@ifundefined{@ordinalMenglish}{\input{fc-english.def}}{}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\let\@ordinalMUKenglish\@ordinalMenglish
\let\@ordinalFUKenglish\@ordinalMenglish
\let\@ordinalNUKenglish\@ordinalMenglish
\let\@numberstringMUKenglish\@numberstringMenglish
\let\@numberstringFUKenglish\@numberstringMenglish
\let\@numberstringNUKenglish\@numberstringMenglish
\let\@NumberstringMUKenglish\@NumberstringMenglish
\let\@NumberstringFUKenglish\@NumberstringMenglish
\let\@NumberstringNUKenglish\@NumberstringMenglish
\let\@ordinalstringMUKenglish\@ordinalstringMenglish
\let\@ordinalstringFUKenglish\@ordinalstringMenglish
\let\@ordinalstringNUKenglish\@ordinalstringMenglish
\let\@OrdinalstringMUKenglish\@OrdinalstringMenglish
\let\@OrdinalstringFUKenglish\@OrdinalstringMenglish
\let\@OrdinalstringNUKenglish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-UKenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-USenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-USenglish.def}
% US English definitions
%    \begin{macrocode}
\ProvidesFile{fc-USenglish}[2007/06/14]
%    \end{macrocode}
% Check that fc-english.def has been loaded
%    \begin{macrocode}
\@ifundefined{@ordinalMenglish}{\input{fc-english.def}}{}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\let\@ordinalMUSenglish\@ordinalMenglish
\let\@ordinalFUSenglish\@ordinalMenglish
\let\@ordinalNUSenglish\@ordinalMenglish
\let\@numberstringMUSenglish\@numberstringMenglish
\let\@numberstringFUSenglish\@numberstringMenglish
\let\@numberstringNUSenglish\@numberstringMenglish
\let\@NumberstringMUSenglish\@NumberstringMenglish
\let\@NumberstringFUSenglish\@NumberstringMenglish
\let\@NumberstringNUSenglish\@NumberstringMenglish
\let\@ordinalstringMUSenglish\@ordinalstringMenglish
\let\@ordinalstringFUSenglish\@ordinalstringMenglish
\let\@ordinalstringNUSenglish\@ordinalstringMenglish
\let\@OrdinalstringMUSenglish\@OrdinalstringMenglish
\let\@OrdinalstringFUSenglish\@OrdinalstringMenglish
\let\@OrdinalstringNUSenglish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-USenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fmtcount.perl>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
# File        : fmtcount.perl
# Author      : Nicola Talbot
# Date        : 26 May 2007
# Version     : 1.05
# Description : LaTeX2HTML implementation of fmtcount package

package main;

sub do_fmtcount_raise{
   local($tmp)="";

   $tmp .= 'sub do_cmd_fmtord{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($suffix) = &missing_braces unless (s/$next_pair_pr_rx/$suffix=$2;\'\'/eo);';
   $tmp .= 'join("", "<SUP>",$suffix,"</SUP>",$_);';
   $tmp .='}';

   eval($tmp);
}

sub do_fmtcount_level{
   local($tmp)="";

   $tmp .= 'sub do_cmd_fmtord{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($suffix) = &missing_braces unless (s/$next_pair_pr_rx/$suffix=$2;\'\'/eo);';
   $tmp .= 'join("", $suffix,$_);';
   $tmp .='}';

   eval($tmp);
}

if (not defined &do_cmd_fmtord)
{
   &do_fmtcount_raise(@_);
}

$frenchdialect = 'france';
$ordinalabbrv = 0;

sub get_ordinal_suffix_english{
   local($num,$gender) = @_;
   local($suffix);

   if ((($num % 10) == 1) && ($num%100 != 11))
   {
      $suffix = 'st';
   }
   elsif ((($num % 10) == 2) && ($num%100 != 12))
   {
      $suffix = 'nd';
   }
   elsif ((($num % 10) == 3) && ($num%100 != 13))
   {
      $suffix = 'rd';
   }
   else
   {
      $suffix = 'th';
   }

   $suffix;
}

sub get_ordinal_suffix_french{
   local($num,$gender) = @_;
   local($_);

   if ($ordinalabbrv > 0)
   {
      $_ = 'e';
   }
   else
   {
      if ($num == 1)
      {
         $_ =  ($gender eq 'f' ? 'ere' : 'er');
      }
      else
      {
         $_ = 'eme';
      }
   }
}

sub get_ordinal_suffix_spanish{
   local($num,$gender) = @_;

   ($gender eq 'f' ? 'a' : 'o');
}

sub get_ordinal_suffix_portuges{
   local($num,$gender) = @_;

   ($gender eq 'f' ? 'a' : 'o');
}

sub get_ordinal_suffix_german{
   local($num,$gender) = @_;

   '';
}

sub get_ordinal_suffix_ngerman{
   local($num,$gender) = @_;

   '';
}

sub get_ordinal_suffix{
   local($num,$gender) = @_;
   local($suffix,$suffixsub);

   $suffixsub = "get_ordinal_suffix_$default_language";

   if (defined ($suffixsub))
   {
      $suffix = &$suffixsub($num,$gender);
   }
   else
   {
      $suffix = &get_ordinal_suffix_english($num,$gender);
   }

   $suffix;
}

sub getordinal{
   local($num,$gender) = @_;
   local($suffix) = &get_ordinal_suffix($num,$gender);
   local($text)='';

   if ($suffix eq '')
   {
      $text = $num;
   }
   else
   {
      local($br_id) = ++$global{'max_id'};
      $text = $num . "\\fmtord${OP}$br_id${CP}$suffix${OP}$br_id${CP}";
   }

   $text;
}

sub do_cmd_ordinalnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   my($gender)='m';
   local($suffix)='';

   if (s/\[([mfn])\]//)
   {
      $gender = $1;
   }

   $suffix = &get_ordinal_suffix($num,$gender);

   local($br_id) = ++$global{'max_id'};
   join('', $num, "\\fmtord${OP}$br_id${CP}$suffix${OP}$br_id${CP}", $_);
}

sub do_cmd_FCordinal{
   &do_cmd_ordinal;
}

sub do_cmd_ordinal{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $str eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{ORDINAL{', $ctr, '}}', $_[0]);
   }
   else
   {
      join('', &getordinal($val, $gender), $_[0]);
   }
}

sub do_cmd_storeordinal{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{ORDINAL{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = &getordinal($val, $gender);
   }

   $_;
}

sub do_cmd_storeordinalnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[([mfn])\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = &getordinal($val, $gender);

   $_;
}

@unitthstring = ('zeroth', 
                 'first', 
                 'second', 
                 'third', 
                 'fourth', 
                 'fifth', 
                 'sixth', 
                 'seventh', 
                 'eighth', 
                 'ninth');

@tenthstring  = ('', 
                 'tenth', 
                 'twentieth', 
                 'thirtieth', 
                 'fortieth', 
                 'fiftieth', 
                 'sixtieth', 
                 'seventieth', 
                 'eightieth', 
                 'ninetieth');

@teenthstring = ('tenth', 
                 'eleventh', 
                 'twelfth', 
                 'thirteenth', 
                 'fourteenth', 
                 'fifteenth', 
                 'sixteenth',  
                 'seventeenth', 
                 'eighteenth', 
                 'nineteenth');

@unitstring = ('zero',
               'one',
               'two',
               'three',
               'four',
               'five',
               'six',
               'seven',
               'eight',
               'nine');

@teenstring = ('ten',
              'eleven',
              'twelve',
              'thirteen',
              'fourteen',
              'fifteen',
              'sixteen',
              'seventeen',
              'eighteen',
              'nineteen');
@tenstring  = ('',
              'ten',
              'twenty',
              'thirty',
              'forty',
              'fifty',
              'sixty',
              'seventy',
              'eighty',
              'ninety');

$hundredname    = "hundred";
$hundredthname  = "hundredth";
$thousandname   = "thousand";
$thousandthname = "thousandth";

sub get_numberstringenglish{
   local($num) = @_;
   local($name)="";

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = &get_numberstringenglish($num/1000);
         $name .= $thousands . " $thousandname";
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = &get_numberstringenglish($num/100);
         $name .= $hundreds . " $hundredname";
         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " and "; }

      if ($num >= 20)
      {
         $name .= $tenstring[$num/10];

         if ($num%10 > 0) { $name .= '-'; }
      }

      if (($num >= 10) && ($num < 20))
      {
         $name .= $teenstring[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitstring[$num%10];
      }
   } 

   $name;
}

@unitthstringfrench = ('zeroi\`eme', 
                 'uni\`eme', 
                 'deuxi\`eme', 
                 'troisi\`eme', 
                 'quatri\`eme', 
                 'cinqui\`eme', 
                 'sixi\`eme', 
                 'septi\`eme', 
                 'huiti\`eme', 
                 'neuvi\`eme');

@tenthstringfrench  = ('', 
                 'dixi\`eme', 
                 'vingti\`eme', 
                 'trentri\`eme', 
                 'quaranti\`eme', 
                 'cinquanti\`eme', 
                 'soixanti\`eme', 
                 'septenti\`eme', 
                 'huitanti\`eme', 
                 'nonenti\`eme');

@teenthstringfrench = ('dixi\`eme', 
                 'onzi\`eme', 
                 'douzi\`eme', 
                 'treizi\`eme', 
                 'quatorzi\`eme', 
                 'quinzi\`eme', 
                 'seizi\`eme',  
                 'dix-septi\`eme', 
                 'dix-huiti\`eme', 
                 'dix-neuvi\`eme');

@unitstringfrench = ('zero',
               'un',
               'deux',
               'trois',
               'quatre',
               'cinq',
               'six',
               'sept',
               'huit',
               'neuf');

@teenstringfrench = ('dix',
              'onze',
              'douze',
              'treize',
              'quatorze',
              'quinze',
              'seize',
              'dix-sept',
              'dix-huit',
              'dix-neuf');

@tenstringfrench  = ('',
              'dix',
              'vingt',
              'trente',
              'quarante',
              'cinquante',
              'soixante',
              'septente',
              'huitante',
              'nonente');

$hundrednamefrench    = "cent";
$hundredthnamefrench  = "centi\\`eme";
$thousandnamefrench   = "mille";
$thousandthnamefrench = "mili\\`eme";

@unitthstringspanish = ('cero', 
                 'primero', 
                 'segundo', 
                 'tercero', 
                 'cuarto', 
                 'quinto', 
                 'sexto', 
                 's\\\'eptimo', 
                 'octavo', 
                 'noveno');

@tenthstringspanish  = ('', 
                 'd\\\'ecimo', 
                 'vig\\\'esimo', 
                 'trig\\\'esimo', 
                 'cuadrag\\\'esimo', 
                 'quincuag\\\'esimo', 
                 'sexag\\\'esimo', 
                 'septuag\\\'esimo', 
                 'octog\\\'esimo', 
                 'nonag\\\'esimo');

@teenthstringspanish = ('d\\\'ecimo', 
                 'und\\\'ecimo', 
                 'duod\\\'ecimo', 
                 'decimotercero', 
                 'decimocuarto', 
                 'decimoquinto', 
                 'decimosexto',  
                 'decimos\\\'eptimo', 
                 'decimoctavo', 
                 'decimonoveno');

@hundredthstringspanish  = ('',
              'cent\\\'esimo',
              'ducent\\\'esimo',
              'tricent\\\'esimo',
              'cuadringent\\\'esimo',
              'quingent\\\'esimo',
              'sexcent\\\'esimo',
              'septing\\\'esimo',
              'octingent\\\'esimo',
              'noningent\\\'esimo');

@unitstringspanish = ('cero',
               'uno',
               'dos',
               'tres',
               'cuatro',
               'cinco',
               'seis',
               'siete',
               'ocho',
               'nueve');

@teenstringspanish = ('diez',
              'once',
              'doce',
              'trece',
              'catorce',
              'quince',
              'diecis\\\'eis',
              'diecisiete',
              'dieciocho',
              'diecinueve');

@twentystringspanish = ('viente',
              'vientiuno',
              'vientid\\\'os',
              'vientitr\\\'es',
              'vienticuatro',
              'vienticinco',
              'vientis\\\'eis',
              'vientisiete',
              'vientiocho',
              'vientinueve');

@tenstringspanish  = ('',
              'diez',
              'viente',
              'treinta',
              'cuarenta',
              'cincuenta',
              'sesenta',
              'setenta',
              'ochenta',
              'noventa');

@hundredstringspanish  = ('',
              'ciento',
              'doscientos',
              'trescientos',
              'cuatrocientos',
              'quinientos',
              'seiscientos',
              'setecientos',
              'ochocientos',
              'novecientos');

$hundrednamespanish    = "cien";
$hundredthnamespanish  = "centi\\`eme";
$thousandnamespanish   = "mil";
$thousandthnamespanish = "mil\\'esimo";

@unitthstringportuges = ('zero', 
                 'primeiro', 
                 'segundo', 
                 'terceiro', 
                 'quatro', 
                 'quinto', 
                 'sexto', 
                 's\\\'etimo', 
                 'oitavo', 
                 'nono');

@tenthstringportuges  = ('', 
                 'd\\\'ecimo', 
                 'vig\\\'esimo', 
                 'trig\\\'esimo', 
                 'quadrag\\\'esimo', 
                 'q\"uinquag\\\'esimo', 
                 'sexag\\\'esimo', 
                 'setuag\\\'esimo', 
                 'octog\\\'esimo', 
                 'nonag\\\'esimo');

@hundredthstringportuges  = ('',
              'cent\\\'esimo',
              'ducent\\\'esimo',
              'trecent\\\'esimo',
              'quadringent\\\'esimo',
              'q\"uingent\\\'esimo',
              'seiscent\\\'esimo',
              'setingent\\\'esimo',
              'octingent\\\'esimo',
              'nongent\\\'esimo');

@unitstringportuges = ('zero',
               'um',
               'dois',
               'tr\^es',
               'quatro',
               'cinco',
               'seis',
               'sete',
               'oito',
               'nove');

@teenstringportuges = ('dez',
              'onze',
              'doze',
              'treze',
              'quatorze',
              'quinze',
              'dezesseis',
              'dezessete',
              'dezoito',
              'dezenove');

@tenstringportuges  = ('',
              'dez',
              'vinte',
              'trinta',
              'quaranta',
              'cinq\"uenta',
              'sessenta',
              'setenta',
              'oitenta',
              'noventa');

@hundredstringportuges  = ('',
              'cento',
              'duzentos',
              'trezentos',
              'quatrocentos',
              'quinhentos',
              'seiscentos',
              'setecentos',
              'oitocentos',
              'novecentos');

$hundrednameportuges    = "cem";
$thousandnameportuges   = "mil";
$thousandthnameportuges = "mil\\'esimo";

sub get_numberstringfrench{
   local($num,$gender) = @_;
   local($name)="";

   if ($gender eq 'f')
   {
      $unitstringfrench[1] = 'une'; 
   }
   else
   {
      $unitstringfrench[1] = 'un'; 
   }

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = '';

         if ($num >= 2000)
         {
            $thousands = &get_numberstringfrench($num/1000,$gender).' ';
         }

         $name .= $thousands . $thousandnamefrench;
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = '';

         if ($num >= 200)
         {
            $hundreds = &get_numberstringfrench($num/100,$gender).' ';
         }

         $name .= $hundreds . $hundrednamefrench;
         $num = $num%100;

         if (($_[0]%100 == 0) && ($_[0]/100 > 1))
         {
           $name .= 's';
         }
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " "; }

      if ($num >= 20)
      {
         if ($frenchdialect eq 'france' and $num >= 70)
         {
            if ($num < 80)
            {
               $name .= $tenstringfrench[6];

               if ($num%10 == 1)
               {
                  $name .= ' et ';
               }
               else
               {
                  $name .= '-';
               }

               $num = 10+($num%10);
            }
            else
            {
               $name .= 'quatre-vingt' . ($num==80?'s':'-');

               if ($num >= 90)
               {
                  $num = 10+($num%10);
               }
            }
         }
         elsif ($frenchdialect eq 'belgian' 
            && ($num >= 80) && ($num < 90))
         {
            $name .= 'quatre-vingt' . ($num==80?'s':'-');
         }
         else
         {
            $name .= $tenstringfrench[$num/10];

            if ($num%10 == 1) { $name .= ' et ';}
            elsif ($num%10 > 0) { $name .= '-'; }
         }
      }

      if (($num >= 10) && ($num < 20))
      {
         $name .= $teenstringfrench[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitstringfrench[$num%10];
      }
   } 

   $name;
}

sub get_numberstringspanish{
   local($num,$gender) = @_;
   local($name)="";

   if ($gender eq 'f')
   {
      $unitstringspanish[1] = 'una'; 
   }
   else
   {
      $unitstringspanish[1] = 'uno'; 
   }

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = '';

         if ($num >= 2000)
         {
            $thousands = &get_numberstringspanish($num/1000,$gender).' ';
         }

         $name .= $thousands . $thousandnamespanish;
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = '';

         if ($num > 100)
         {
            $hundreds = $hundredstringspanish[$num/100];
         }
         else
         {
            $hundreds = 'cien';
         }

         $name .= $hundreds;
         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " y "; }


      if ($num >= 30)
      {
         $name .= $tenstringspanish[$num/10];

         if ($num%10 > 0) { $name .= ' y '; }
      }

      if (($num >=20) && ($num < 30))
      {
         $name .= $twentystringspanish[$num%10];
      }
      elsif (($num >= 10) && ($num < 20))
      {
         $name .= $teenstringspanish[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitstringspanish[$num%10];
      }
   } 

   $name;
}

sub get_numberstringportuges{
   local($num,$gender) = @_;
   local($name)="";

   if ($gender eq 'f')
   {
      $unitstringportuges[0] = 'zera';
      $unitstringportuges[1] = 'uma';
      $unitstringportuges[2] = 'duas';
   }
   else
   {
      $unitstringportuges[0] = 'zero';
      $unitstringportuges[1] = 'um';
      $unitstringportuges[2] = 'dois';
   }

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = '';

         if ($num >= 2000)
         {
            $thousands = &get_numberstringportuges($num/1000,$gender).' ';
         }

         $name .= $thousands . $thousandnameportuges;
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = '';

         if ($num > 100)
         {
            $hundreds = $hundredstringportuges[$num/100];

            if ($gender eq 'f' and $num >= 200)
            {
               $hundreds =~s/o(s?)$/a\1/;
            }
         }
         else
         {
            $hundreds = $hundrednameportuges;
         }

         $name .= $hundreds;
         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " e "; }

      if ($num >= 20)
      {
         $name .= $tenstringportuges[$num/10];

         if ($num%10 == 1) { $name .= ' e ';}
         elsif ($num%10 > 0) { $name .= ' '; }
      }

      if (($num >= 10) && ($num < 20))
      {
         $name .= $teenstringportuges[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitstringportuges[$num%10];
      }
   } 

   $name;
}

@unitthstringMgerman = ('nullter', 
                 'erster', 
                 'zweiter', 
                 'dritter', 
                 'vierter', 
                 'f\\"unter', 
                 'sechster', 
                 'siebter', 
                 'achter', 
                 'neunter');

@tenthstringMgerman  = ('', 
                 'zehnter', 
                 'zwanzigster', 
                 'drei\\ss igster', 
                 'vierzigster', 
                 'f\\"unfzigster', 
                 'sechzigster', 
                 'siebzigster', 
                 'achtzigster', 
                 'neunzigster');

@teenthstringMgerman = ('zehnter', 
                 'elfter', 
                 'zw\\"olfter', 
                 'dreizehnter', 
                 'vierzehnter', 
                 'f\\"unfzehnter', 
                 'sechzehnter',  
                 'siebzehnter', 
                 'achtzehnter', 
                 'neunzehnter');

@unitthstringFgerman = ('nullte', 
                 'erste', 
                 'zweite', 
                 'dritte', 
                 'vierte', 
                 'f\\"unfte', 
                 'sechste', 
                 'siebte', 
                 'achte', 
                 'neunte');

@tenthstringFgerman  = ('', 
                 'zehnte', 
                 'zwanzigste', 
                 'drei\\ss igste', 
                 'vierzigste', 
                 'f\\"unfzigste', 
                 'sechzigste', 
                 'siebzigste', 
                 'achtzigste', 
                 'neunzigste');

@teenthstringFgerman = ('zehnte', 
                 'elfte', 
                 'zw\\"olfte', 
                 'dreizehnte', 
                 'vierzehnte', 
                 'f\\"unfzehnte', 
                 'sechzehnte',  
                 'siebzehnte', 
                 'achtzehnte', 
                 'neunzehnte');

@unitthstringNgerman = ('nulltes', 
                 'erstes', 
                 'zweites', 
                 'drittes', 
                 'viertes', 
                 'f\\"unte', 
                 'sechstes', 
                 'siebtes', 
                 'achtes', 
                 'neuntes');

@tenthstringNgerman  = ('', 
                 'zehntes', 
                 'zwanzigstes', 
                 'drei\\ss igstes', 
                 'vierzigstes', 
                 'f\\"unfzigstes', 
                 'sechzigstes', 
                 'siebzigstes', 
                 'achtzigstes', 
                 'neunzigstes');

@teenthstringNgerman = ('zehntes', 
                 'elftes', 
                 'zw\\"olftes', 
                 'dreizehntes', 
                 'vierzehntes', 
                 'f\\"unfzehntes', 
                 'sechzehntes',  
                 'siebzehntes', 
                 'achtzehntes', 
                 'neunzehntes');

@unitstringgerman = ('null',
               'ein', # eins dealt with separately (this is for prefixes)
               'zwei',
               'drei',
               'vier',
               'f\\"unf',
               'sechs',
               'sieben',
               'acht',
               'neun');

@teenstringgerman = ('zehn',
              'elf',
              'zw\\"olf',
              'dreizehn',
              'vierzehn',
              'f\\"unfzehn',
              'sechzehn',
              'siebzehn',
              'achtzehn',
              'neunzehn');

@tenstringgerman  = ('',
              'zehn',
              'zwanzig',
              'drei\\ss ig',
              'vierzig',
              'f\\"unfzig',
              'sechzig',
              'siebzig',
              'achtzig',
              'neunzig');

sub do_cmd_einhundert{
   local($_) = @_;

   "einhundert$_";
}

sub do_cmd_eintausend{
   local($_) = @_;

   "eintausend$_";
}

sub get_numberunderhundredgerman{
   local($num)=@_;
   local($name)='';

   if ($num == 1)
   {
      $name = 'eins';
   }
   elsif ($num < 10)
   {
      $name = $unitstringgerman[$num];
   }
   elsif ($num%10 == 0)
   {
      $name = $tenstringgerman[$num/10];
   }
   else
   {
      $name = join('und', $unitstringgerman[$num%10],
                          $tenstringgerman[$num/10]);
   }

   $name;
}

sub get_numberstringgerman{
   local($orgnum,$gender) = @_;
   local($name)="";

   local($num) = $orgnum;

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000 and $num < 2000)
      {
         $name = &translate_commands("\\eintausend ");
      }
      elsif ($num >= 2000)
      {
         $name = &get_numberunderhundredgerman($num/1000)
               . "tausend";
      }

      $num = $orgnum%1000;

      if ($num >= 100 and $num < 200)
      {
         if ($orgnum > 1000)
         {
            $name .= "einhundert";
         }
         else
         {
            $name = &translate_commands("\\einhundert ");
         }
      }
      elsif ($num >= 200)
      {
         $name .= $unitstringgerman[$num/100]."hundert";
      }

      $num = $num%100;

      if ($orgnum == 0)
      {
         $name = 'null';
      }
      elsif ($num > 0)
      {
         $name .= &get_numberunderhundredgerman($num);
      }
   } 

   $name;
}

sub get_numberstring{
   local($val,$gender) = @_;

   if ($default_language eq 'french')
   {
      &get_numberstringfrench($val,$gender);
   }
   elsif ($default_language eq 'spanish')
   {
      &get_numberstringspanish($val,$gender);
   }
   elsif ($default_language eq 'portuges')
   {
      &get_numberstringportuges($val,$gender);
   }
   elsif ($default_language eq 'german' 
       or $default_language eq 'ngerman')
   {
      &get_numberstringgerman($val,$gender);
   }
   else
   {
      &get_numberstringenglish($val);
   }
}

sub do_cmd_numberstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces unless 
      s/$next_pair_pr_rx/$num=$2;''/eo;

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', &get_numberstring($num,$gender), $_);
}

sub do_cmd_numberstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{NUMBERSTRING{', $ctr, '}}', $_[0]);
   }
   else
   {
      join('', &get_numberstring($val, $gender), $_[0]);
   }
}

sub do_cmd_storenumberstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{NUMBERSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = join('', &get_numberstring($val, $gender));
   }

   $_;
}

sub do_cmd_storenumberstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[([mfn])\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = join('', &get_numberstring($val, $gender));

   $_;
}

sub get_Numberstring{
   local($val,$gender) = @_;
   local($string) = &get_numberstring($val,$gender);

   if ($default_language=~m/german/)
   {
      $string =~ s/([a-z])([^\s\-]+)/\u\1\2/;
   }
   else
   {
      $string =~ s/([a-z])([^\s\-]+)/\u\1\2/g;

      if ($default_language eq 'french')
      {
         $string =~ s/ Et / et /g;
      }
      elsif ($default_language eq 'spanish')
      {
         $string =~ s/ Y / y /g;
      }
      elsif ($default_language eq 'portuges')
      {
         $string =~ s/ E / e /g;
      }
      else
      {
         $string =~ s/ And / and /g;
      }
   }

   $string;
}

sub do_cmd_Numberstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces 
          unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', &get_Numberstring($num,$gender), $_);
}

sub do_cmd_Numberstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{NNUMBERSTRING{', $ctr, '}}', $_[0]);
   }
   else
   {
      join('', &get_Numberstring($val, $gender), $_[0]);
   }
}

sub do_cmd_storeNumberstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[([mfn])\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{NNUMBERSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = join('', &get_Numberstring($val, $gender));
   }

   $_;
}

sub do_cmd_storeNumberstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[([mfn])\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = join('', &get_Numberstring($val, $gender));

   $_;
}

sub do_cmd_NUMBERstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces 
          unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', uc(&get_numberstring($num,$gender)), $_);
}

sub do_cmd_NUMBERstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{CAPNUMBERSTRING{', $ctr, '}}', $_);
   }
   else
   {
      join('', uc(&get_numberstring($val, $gender)), $_);
   }
}

sub do_cmd_storeNUMBERstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{CAPNUMBERSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = uc(&get_numberstring($val, $gender));
   }

   $_;
}

sub do_cmd_storeNUMBERstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[([mfn])\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = uc(&get_numberstring($val, $gender));

   $_;
}

sub get_ordinalstringenglish{
   local($num) = @_;
   local($name)="";

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = &get_numberstring($num/1000);
         $name .= $thousands;

         if ($num%1000 > 0)
         {
            $name .= " $thousandname";
         }
         else
         {
            $name .= " $thousandthname";
         }

         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = &get_numberstring($num/100);
         $name .= $hundreds;

         if ($num%100 > 0)
         {
            $name .= " $hundredname";
         }
         else
         {
            $name .= " $hundredthname";
         }

         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " and "; }

      if ($num >= 20)
      {
         if ($num%10 > 0)
         {
            $name .= $tenstring[$num/10] . '-';
         }
         else
         {
            $name .= $tenthstring[$num/10];
         }
      }

      if (($num >= 10) && ($num < 20))
      {
         $name .= $teenthstring[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitthstring[$num%10];
      }
   }  

   $name;
}

sub get_ordinalstringfrench{
   local($num,$gender) = @_;
   local($name)="";

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         local($thousands) = '';

         if ($num >= 2000)
         {
            $thousands = &get_numberstringfrench($num/1000,$gender).' ';
         }

         $num = $num%1000;

         if ($num > 0)
         {
            $name .= $thousands . $thousandnamefrench;
         }
         else
         {
            $name .= $thousands . $thousandthnamefrench;
         }
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = '';

         if ($num >= 200)
         {
            $hundreds = &get_numberstringfrench($num/100,$gender).' ';
         }

         $num = $num%100;

         if ($num > 0)
         {
            $name .= $hundreds . $hundrednamefrench;
         }
         else
         {
            $name .= $hundreds . $hundredthnamefrench;
         }
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " "; }

      if ($num >= 20)
      {
         if ($frenchdialect eq 'france' and $num >= 70)
         {
            if ($num < 80)
            {
               if ($num%10 > 0)
               {
                  $name .= $tenstringfrench[6];
               }
               else
               {
                  $name .= $tenthstringfrench[6];
               }

               if ($num%10 == 1)
               {
                  $name .= ' et ';
               }
               else
               {
                  $name .= '-';
               }

               $num = 10+($num%10);
            }
            else
            {
               $name .= 'quatre-vingt' . ($num==80?'i\`eme':'-');

               if ($num >= 90)
               {
                  $num = 10+($num%10);
               }
            }
         }
         elsif ($frenchdialect eq 'belgian' and $num >= 80)
         {
            $name .= 'quatre-vingt' . ($num==80?'i\`eme':'-');

            if ($num >= 90)
            {
               $num = 10+($num%10);
            }
         }
         else
         {
            if ($num%10 > 0)
            {
               $name .= $tenstringfrench[$num/10];
            }
            else
            {
               $name .= $tenthstringfrench[$num/10];
            }

            if ($num%10 == 1) { $name .= ' et ';}
            elsif ($num%10 > 0) { $name .= '-'; }
         }
      }

      if (($num >= 10) && ($num < 20))
      {
         $name .= $teenthstringfrench[$num%10];
      }
      elsif ($_[0] == 1)
      {
         $name = 'premi\`ere';
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $name .= $unitthstringfrench[$num%10];
      }
   } 

   $name;
}

sub get_ordinalstringspanish{
   local($num,$gender) = @_;
   local($name)="";
   local($str);

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         if ($num >= 2000)
         {
            local($thousands) = &get_ordinalstringspanish($num/1000);

            if ($gender eq 'f')
            {
               $thousands =~s/o(s?)$/a\1/;
            }
         
            $name .= $thousands. " ";
         }
         else
         {
            $name = "";
         }

         $name .= "$thousandthnamespanish";

         if ($gender eq 'f')
         {
            $name =~s/o$/a/;
         }
         
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = $hundredthstringspanish[$num/100];

         if ($gender eq 'f')
         {
            $hundreds =~s/o$/a/;
         }
         
         $name .= $hundreds;

         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= " "; }

      local($lastbit)="";

      if ($num >= 20)
      {
         $lastbit = $tenthstringspanish[$num/10];

         if ($num%10 > 0)
         {
            $lastbit .=  ' ';
         }

         if ($gender eq 'f')
         {
            $lastbit =~s/o([ s]*)$/a\1/;
         }

         $name .= $lastbit;

         $lastbit = "";
      }

      if (($num >= 10) && ($num < 20))
      {
         $lastbit = $teenthstringspanish[$num%10];
      }
      elsif (($num%10 > 0) || ($_[0] == 0))
      {
         $lastbit = $unitthstringspanish[$num%10];
      }

      if ($gender eq 'f')
      {
         $lastbit =~s/o([ s]*)$/a\1/;
      }

      $name .= $lastbit;
   }  

   $name;
}

sub get_ordinalstringportuges{
   local($num,$gender) = @_;
   local($name)="";
   local($str);

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000)
      {
         if ($num >= 2000)
         {
            local($thousands) = &get_ordinalstringportuges($num/1000);

            if ($gender eq 'f')
            {
               $thousands =~s/o(s?)$/a\1/;
            }
         
            $name .= $thousands. " ";
         }
         else
         {
            $name = "";
         }

         $name .= "$thousandthnameportuges";

         if ($gender eq 'f')
         {
            $name =~s/o$/a/;
         }
         
         $num = $num%1000;
      }

      if ($num >= 100)
      {
         if ($_[0] >= 1000) { $name .= " "; }

         local($hundreds) = $hundredthstringportuges[$num/100];

         if ($gender eq 'f')
         {
            $hundreds =~s/o$/a/;
         }
         
         $name .= $hundreds;

         $num = $num%100;
      }

      if (($_[0] > 100) && ($_[0]%100 > 0)) { $name .= "-"; }

      local($lastbit)="";

      if ($num >= 10)
      {
         $lastbit = $tenthstringportuges[$num/10];

         if ($num%10 > 0)
         {
            $lastbit .=  '-';
         }

         if ($gender eq 'f')
         {
            $lastbit =~s/o([ s]*)$/a\1/;
         }

         $name .= $lastbit;

         $lastbit = "";
      }

      if (($num%10 > 0) || ($_[0] == 0))
      {
         $lastbit = $unitthstringportuges[$num%10];
      }

      if ($gender eq 'f')
      {
         $lastbit =~s/o([ s]*)$/a\1/;
      }

      $name .= $lastbit;
   }  

   $name;
}

sub get_numberunderhundredthgerman{
   local($num,$gender)=@_;
   local($name)='';

   if ($num < 10)
   {
      if ($gender eq 'F')
      {
         $name = $unitthstringFgerman[$num];
      }
      elsif ($gender eq 'N')
      {
         $name = $unitthstringNgerman[$num];
      }
      else
      {
         $name = $unitthstringMgerman[$num];
      }
   }
   elsif ($num%10 == 0)
   {
      if ($gender eq 'F')
      {
         $name = $tenthstringFgerman[$num/10];
      }
      elsif ($gender eq 'N')
      {
         $name = $tenthstringNgerman[$num/10];
      }
      else
      {
         $name = $tenthstringMgerman[$num/10];
      }
   }
   else
   {
      local($tenth);
      if ($gender eq 'F')
      {
         $tenth = $tenthstringFgerman[$num/10];
      }
      elsif ($gender eq 'N')
      {
         $tenth = $tenthstringNgerman[$num/10];
      }
      else
      {
         $tenth = $tenthstringMgerman[$num/10];
      }

      $name = join('und', $unitstringgerman[$num%10], $tenth);
   }

   $name;
}

sub get_ordinalstringgerman{
   local($orgnum,$gender) = @_;
   local($name)="";
   local($suffix)='';

   $gender = uc($gender);

   if ($gender eq 'F')
   {
      $suffix = 'ste';
   }
   elsif ($gender eq 'N')
   {
      $suffix = 'stes';
   }
   else
   {
      $suffix = 'ster';
      $gender = 'M';
   }

   local($num) = $orgnum;

   unless (($num >= 1000000) || ($num < 0))
   {
      if ($num >= 1000 and $num < 2000)
      {
         $name = &translate_commands("\\eintausend ");
      }
      elsif ($num >= 2000)
      {
         $name = &get_numberunderhundredgerman($num/1000)
               . "tausend";
      }

      $num = $orgnum%1000;

      # is that it or is there more?
      if ($orgnum >= 1000 and $num == 0)
      {
         $name .= $suffix;
         return $name;
      }

      if ($num >= 100 and $num < 200)
      {
         if ($orgnum > 1000)
         {
            $name .= "einhundert";
         }
         else
         {
            $name = &translate_commands("\\einhundert ");
         }
      }
      elsif ($num >= 200)
      {
         $name .= $unitstringgerman[$num/100]."hundert";
      }

      $num = $num%100;

      # is that it or is there more?
      if ($orgnum >= 100 and $num == 0)
      {
         $name .= $suffix;
         return $name;
      }

      if ($orgnum == 0)
      {
         if ($gender eq 'F')
         {
            $name = $unitthstringFgerman[0];
         }
         elsif ($gender eq 'N')
         {
            $name = $unitthstringNgerman[0];
         }
         else
         {
            $name = $unitthstringMgerman[0];
         }
      }
      elsif ($num > 0)
      {
         $name .= &get_numberunderhundredthgerman($num,$gender);
      }
   } 

   $name;
}

sub get_ordinalstring{
   local($val,$gender) = @_;

   if ($default_language eq 'french')
   {
      &get_ordinalstringfrench($val,$gender);
   }
   elsif ($default_language eq 'spanish')
   {
      &get_ordinalstringspanish($val,$gender);
   }
   elsif ($default_language eq 'portuges')
   {
      &get_ordinalstringportuges($val,$gender);
   }
   elsif ($default_language eq 'german'
        or $default_language eq 'ngerman')
   {
      &get_ordinalstringgerman($val,$gender);
   }
   else
   {
      &get_ordinalstringenglish($val);
   }
}

sub do_cmd_ordinalstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces 
          unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', &get_ordinalstring($num,$gender), $_);
}

sub do_cmd_ordinalstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{ORDINALSTRING{', $ctr, '}}', $_);
   }
   else
   {
      join('', &get_ordinalstring($val, $gender), $_);
   }
}

 %fmtcntvar = ();

sub do_cmd_FMCuse{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $fmtcntvar{$key}.$_;
}

sub do_cmd_storeordinalstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{ORDINALSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = join('', &get_ordinalstring($val, $gender));
   }

   $_;
}

sub do_cmd_storeordinalstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = join('', &get_ordinalstring($val, $gender));

   $_;
}

sub get_Ordinalstring{
   local($val,$gender) = @_;
   local($string) = &get_ordinalstring($val,$gender);

   if ($default_language=~m/german/)
   {
      $string =~ s/\b([a-z])([^\s\-]+)/\u\1\2/;
   }
   else
   {
      $string =~ s/\b([a-z])([^\s\-]+)/\u\1\2/g;

      if ($default_language eq 'french')
      {
         $string =~ s/ Et / et /g;
      }
      else
      {
         $string =~ s/ And / and /g;
      }
   }

   $string;
}

sub do_cmd_Ordinalstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces 
          unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', &get_Ordinalstring($num,$gender), $_);
}

sub do_cmd_Ordinalstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{OORDINALSTRING{', $ctr, '}}', $_[0]);
   }
   else
   {
      join('', &get_Ordinalstring($val, $gender), $_[0]);
   }
}

sub do_cmd_storeOrdinalstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{OORDINALSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = join('', &get_Ordinalstring($val, $gender));
   }

   $_;
}

sub do_cmd_storeOrdinalstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = join('', &get_Ordinalstring($val, $gender));

   $_;
}

sub do_cmd_ORDINALstringnum{
   local($_) = @_;
   local($num,$gender);
   $num = &missing_braces 
          unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   if (s/\[(m|f|n)\]//)
   {
      $gender = $1;
   }
   else
   {
      $gender = 'm';
   }

   join('', uc(&get_ordinalstring($num,$gender)), $_);
}

sub do_cmd_ORDINALstring{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   my($gender)='m';

   $_[0] =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_[0]=~s/\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      join('', '{CAPORDINALSTRING{', $ctr, '}}', $_);
   }
   else
   {
      join('', uc(&get_ordinalstring($val, $gender)), $_);
   }
}

sub do_cmd_storeORDINALstring{
   local($_) = @_;
   local($key);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   local($ctr, $val, $id, $_) = &read_counter_value($_);
   my($gender)='m';

   $_ =~ s/${OP}$id${CP}$ctr${OP}$id${CP}//;

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   if ($ctr eq 'DAY' or $ctr eq 'MONTH' or $ctr eq 'YEAR')
   {
      # this is a cludge to make it work with newdateformat
      $fmtcntvar{$key} = join('', '{CAPORDINALSTRING{', $ctr, '}}');
   }
   else
   {
      $fmtcntvar{$key} = uc(&get_ordinalstring($val, $gender));
   }

   $_;
}

sub do_cmd_storeORDINALstringnum{
   local($_) = @_;
   local($key, $val);

   $key = &missing_braces 
          unless ((s/$next_pair_pr_rx//o)&&($key=$2));

   $val = &missing_braces 
          unless (s/$next_pair_pr_rx/$val=$2;''/eo);

   my($gender)='m';

   if ($_ =~s/\s*\[(.)\]//)
   {
      $gender = $1;
   }

   $fmtcntvar{$key} = uc(&get_ordinalstring($val, $gender));

   $_;
}

sub do_cmd_fmtcountsetoptions{
   local($_) = @_;
   local($options) = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($options=$2));

   if ($options =~ m/french=?(\w*)(,|$)/)
   {
      if ($1 eq 'france' or $1 eq 'swiss' or $1 eq 'belgian')
      {
         $frenchdialect = $1;

        print "Using French dialect: $1" if ($VERBOSITY > 0) ;
      }
      elsif ($1 eq '')
      {
         $frenchdialect = 'france';

         print "Using French dialect: france" if ($VERBOSITY > 0);
      }
      else
      {
         &write_warnings("unknown french dialect '$1'");
      }
   }

   if ($options =~ m/abbrv=?(\w*)(,|$)/)
   {
      if ($1 eq 'true' or $1 eq '')
      {
         $ordinalabbrv = 1;

         print "Setting abbrv=true" if ($VERBOSITY > 0);
      }
      elsif ($1 eq 'false')
      {
         $ordinalabbrv = 0;

         print "Setting abbrv=false" if ($VERBOSITY > 0);
      }
      else
      {
         &write_warnings("fmtcountsetoptions key abbrv: unknown value '$1'.");
      }
   }

   if ($options =~ m/fmtord=(\w*)(,|$)/)
   {
      if ($1 eq 'raise')
      {
         &do_fmtcount_raise();

         print "Using raised ordinals" if ($VERBOSITY > 0);
      }
      elsif ($1 eq 'level')
      {
         &do_fmtcount_level();

         print "Using level ordinals" if ($VERBOSITY > 0);
      }
      elsif ($1 eq 'user')
      {
         # do nothing

         print "Using user defined fmtord" if ($VERBOSITY > 0);
      }
      else
      {
         &write_warnings("unknown fmtcount option fmtord=$1");
      }
   }

   $_[0];
}

$padzeroes = 0;

sub do_cmd_padzeroes{
   local($_) = @_;
   local($val,$pat) = &get_next_optional_argument;

   if ($val eq '')
   {
      $padzeroes = 17;
   }
   else
   {
      $padzeroes = $val;
   }

   $_;
}

sub get_binary{
   local($num) = @_;
   local($val) = "";

   for (my $i=17; $i>=0; $i--)
   {
      if (($i < $padzeroes) || ($num & (1 << $i)) || !($val eq ""))
      {
         $val .= ($num & (1 << $i) ? 1 : 0);
      }
   }

   $val;
}

sub do_cmd_binary{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_binary($val), $_);
}

sub do_cmd_binarynum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', &get_binary($num), $_);
}

sub get_decimal{
   local($num) = @_;

   sprintf "%0${padzeroes}d", $num;
}

sub do_cmd_decimal{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_decimal($val), $_);
}

sub do_cmd_decimalnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', &get_decimal($num), $_);
}

sub get_hexadecimal{
   local($num) = @_;

   sprintf "%0${padzeroes}lx", $num;
}

sub do_cmd_hexadecimal{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_hexadecimal($val), $_);
}

sub do_cmd_hexadecimalnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', &get_hexadecimal($num), $_);
}

sub get_Hexadecimal{
   local($num) = @_;

   sprintf "%0${padzeroes}lX", $num;
}

sub do_cmd_Hexadecimal{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_Hexadecimal($val), $_);
}

sub do_cmd_Hexadecimalnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', &get_Hexadecimal($num), $_);
}

sub get_octal{
   local($num) = @_;

   sprintf "%0${padzeroes}lo", $num;
}

sub do_cmd_octal{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_octal($val), $_);
}

sub do_cmd_octalnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', &get_octal($num), $_);
}

sub get_aaalph{
   local($num) = @_;
   local($rep) = int($num/26) + 1;
   local($c) = chr(ord('a')-1+$num%26);

   local($_) = $c x $rep;
}

sub do_cmd_aaalph{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_aaalph($val), $_);
}

sub get_AAAlph{
   local($num) = @_;
   local($rep) = int($num/26) + 1;
   local($c) = chr(ord('A')-1+$num%26);

   local($_) = $c x $rep;
}

sub do_cmd_AAAlph{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);

   join('', &get_AAAlph($val), $_);
}

sub do_cmd_aaalphnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', (sprintf "%${padzeroes}s", &get_aaalph($num)), $_);
}

sub do_cmd_AAAlphnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', uc(sprintf "%${padzeroes}s", &get_aaalph($num)), $_);
}

sub get_abalph{
   local($num) = @_;
   local($str);

   if ($num == 0)
   {
      $str = '';
   }
   elsif ($num > 0 && $num <= 26)
   {
      $str = chr(ord('a')-1+$num);
   }
   else
   {
      $str = &get_abalph(int($num/26)) . chr(ord('a')-1+($num%26));
   }

   $str;
}

sub do_cmd_abalph{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   
   join('', (sprintf "%${padzeroes}s", &get_abalph($val)), $_);
}

sub do_cmd_abalphnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', (sprintf "%${padzeroes}s", &get_abalph($num)), $_);
}

sub do_cmd_ABAlph{
   local($ctr, $val, $id, $_) = &read_counter_value($_[0]);
   
   join('', uc(sprintf "%${padzeroes}s", &get_abalph($val)), $_);
}

sub do_cmd_ABAlphnum{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);
   
   join('', uc(sprintf "%${padzeroes}s", &get_abalph($num)), $_);
}

sub get_twodigit{
   local($num) = @_;

   sprintf "%02d", $num;
}

sub do_cmd_twodigit{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   # this is a cludge
   if ($num eq "THEDAY" or $num eq "THEYEAR" or $num eq "THEMONTH")
   {
      join('', 'TWODIGIT{', $num, '}', $_);
   }
   else
   {
      join('', &get_twodigit($num), $_);
   }
}

# this was put here to help with the definition of \datelatin

sub do_cmd_romannumeral{
   local($_) = @_;
   local($num) = &missing_braces
      unless (s/$next_pair_pr_rx/$num=$2;''/eo);

   # this is a cludge
   if ($num eq "THEDAY" or $num eq "THEYEAR" or $num eq "THEMONTH")
   {
      join('', 'ROMANNUMERAL{', $num, '}', $_);
   }
   else
   {
      join('', &froman($num), $_);
   }
}

# load configuration file if it exists
# Note: The configuration file should be loaded before
# the package options are executed.

# why doesn't this work? If I call this subroutine it 
# causes an infinite loop.

sub load_fmtcount_cfg{
   local($file,$found);

   $file = &fulltexpath('fmtcount.cfg');

   $found = (-f $file);

   if (!$found)
   {
      foreach $texpath (split /$envkey/, $TEXINPUTS)
      {
         $file = "$texpath${dd}fmtcount.cfg";

         last if ($found = (-f $file));
      }
   }

   if ($found)
   {
      print "\nusing configuration file $file\n";

      &slurp_input($file);
      &pre_process;
      &substitute_meta_cmds if (%new_command || %new_environment);
      &wrap_shorthand_environments;
      $_ = &translate_commands(&translate_environments($_));

      print "\n processed size: ".length($_)."\n" if ($VERBOSITY>1)
   }
   else
   {
      print "\nNo configuation file fmtcount.cfg found\n" if ($VERBOSITY>1)
   }
}

1;
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%</fmtcount.perl>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-lang.tex>
%    \end{macrocode}
%\fi
%    \begin{macrocode}
 % This is an interactive script. Run it through \LaTeX
 % and enter appropriate responses. (This won't work with 
 % LaTeX2HTML

\documentclass[a4paper]{article}

\usepackage[french,english,spanish,portuges,ngerman,italian]{babel}
\usepackage{fmtcount}

\newcounter{startval}
\newcounter{endval}
\newcounter{stepsize}
\newcounter{N}
\newcount\myctr
\newcount\langid

\begin{document}

\section{Displaying the value of a counter}

\typeout{This is an interactive script, testing the fmtcount package.}

\langid=-1

\loop
\typeout{Which language?^^J}
\typeout{[1] English}
\typeout{[2] Portuguese}
\typeout{[3] Spanish}
\typeout{[4] French}
\typeout{[5] French (Swiss)}
\typeout{[6] French (Belgium)}
\typeout{[7] German}
\typeout{[8] Italian}

\typein[\response]{}

\ifthenelse{\equal{\response}{1}}{\langid=1}{
\ifthenelse{\equal{\response}{2}}{\langid=2}{
\ifthenelse{\equal{\response}{3}}{\langid=3}{
\ifthenelse{\equal{\response}{4}}{\langid=4\fmtcountsetoptions{french}}{
\ifthenelse{\equal{\response}{5}}{\langid=5\fmtcountsetoptions{french=swiss}}{
\ifthenelse{\equal{\response}{6}}{\langid=6\fmtcountsetoptions{french=belgian}}
{\ifthenelse{\equal{\response}{7}}{\langid=7}{%
\ifthenelse{\equal{\response}{8}}{\langid=8}{%
\langid=-1
\typeout{Invalid response '\response', please select a number from 1 to 6}}}}}}}}}
\ifnum\langid=-1
\repeat

\ifcase\langid
\or \selectlanguage{english}
Current language: English.
\or \selectlanguage{portuges}
Current language: Portuguese.
\or \selectlanguage{spanish}
Current language: Spanish.
\or \selectlanguage{french}
Current language: French.
\or \selectlanguage{french}
Current language: French (Swiss).
\or \selectlanguage{french}
Current language: French (Belgium).
\or \selectlanguage{ngerman}
Current language: German.
\or \selectlanguage{italian}
Current language: Italian.
\fi

\def\startval{-1}

\loop
\typein[\startval]{Start value? (Integer from 0 to 99999)
[Default 1]}
\ifthenelse{\equal{\startval}{}}{\def\startval{1}}{}
\ifnum\startval<0\def\startval{-1}\fi
\ifnum\startval>99999\def\startval{-1}\fi
\ifnum\startval=-1
\repeat

\def\endval{-1}

\loop
\typein[\endval]{End value? (Integer from 0 to 99999)
[Default 1000]}
\ifthenelse{\equal{\endval}{}}{\def\endval{1000}}{}
\ifnum\endval<0\def\endval{-1}\fi
\ifnum\endval>99999\def\endval{-1}\fi
\ifnum\endval=-1
\repeat

\def\stepsize{0}

\loop
\typein[\stepsize]{Step size? (Non zero integer)
[Default 1]}
\ifthenelse{\equal{\stepsize}{}}{\def\stepsize{1}}{}
\ifnum\stepsize=0
\repeat

\typeout{From {\startval} to {\endval} step {\stepsize}}

\ifnum\startval<\endval
\ifnum\stepsize<0
\PackageError{fc-lang}{Infinite loop not permitted!}{}
\def\endval{\startval}
\fi
\fi

\ifnum\startval>\endval
\ifnum\stepsize>0
\PackageError{fc-lang}{Infinite loop not permitted!}{}
\def\endval{\startval}
\fi
\fi

\newcount\numformat

\numformat=-1
\loop
\typeout{Which format?^^J}
\typeout{[1] ordinalstring}
\typeout{[2] Ordinalstring}
\typeout{[3] ORDINALstring}
\typeout{[4] numberstring}
\typeout{[5] Numberstring}
\typeout{[6] NUMBERstring}

\typein[\response]{Default: 1}

\ifthenelse{\equal{\response}{}}{\def\response{1}}{}%default val
\ifthenelse{\equal{\response}{1}}{\numformat=1}{
\ifthenelse{\equal{\response}{2}}{\numformat=2}{
\ifthenelse{\equal{\response}{3}}{\numformat=3}{
\ifthenelse{\equal{\response}{4}}{\numformat=4}{
\ifthenelse{\equal{\response}{5}}{\numformat=5}{
\ifthenelse{\equal{\response}{6}}{\numformat=6}{\numformat=-1
\typeout{Invalid response '\response', please select a number from 1 to 4}}}}}}}
\ifnum\numformat=-1
\repeat

\ifcase\numformat
\or\def\stringtype{ordinalstring}
\or\def\stringtype{Ordinalstring}
\or\def\stringtype{ORDINALstring}
\or\def\stringtype{numberstring}
\or\def\stringtype{Numberstring}
\or\def\stringtype{NUMBERstring}
\fi

\ifnum\langid>3\relax
  \ifnum\langid<7\relax
  \myctr=-1\relax
  \loop
    \typeout{Ordinal type?^^J}
    \typeout{[1] eme}
    \typeout{[2] e}
    \typein[\response]{Default: 1}
    \ifthenelse{\equal{\response}{}}%
      {%
        \def\response{1}% default
        \myctr=1\relax
      }%
      {%
        \ifthenelse{\equal{\response}{1}}%
        {%
          \fmtcountsetoptions{abbrv=false}\myctr=1\relax
        }%
        {%
          \ifthenelse{\equal{\response}{2}}%
          {%
            \fmtcountsetoptions{abbrv}\myctr=2\relax
          }%
          {%
            \myctr=-1\relax
          }%
        }%
      }%
    \ifnum\myctr=-1
  \repeat
  \fi
\fi

\myctr=-1
\loop
\typeout{Ordinal format?^^J}
\typeout{[1] raised}
\typeout{[2] level}
\typein[\response]{Default: 1}
\ifthenelse{\equal{\response}{1}\or\equal{\response}{}}{%
\fmtcountsetoptions{fmtord=raise}\myctr=1}{%
\ifthenelse{\equal{\response}{2}}{%
\fmtcountsetoptions{fmtord=level}\myctr=2}{%
\myctr=-1}}
\ifnum\myctr=-1
\repeat

\ifnum\langid=1
\myctr=1
\else
\ifthenelse{\langid=7 \and \numformat>3}{}{%
\loop
\ifnum\langid=7
  \typein[\response]{Gender? (m, f or n) [Default: m]}
  \ifthenelse{\equal{\response}{m}}{\myctr=1}{
  \ifthenelse{\equal{\response}{f}}{\myctr=2}{
   \ifthenelse{\equal{\response}{n}}{\myctr=3}{
    \ifthenelse{\equal{\response}{}}{\myctr=1}{%
    \myctr=-1
  \typeout{Invalid response '\response'}}}}}
\else
  \typein[\response]{Gender? (m or f) [Default: m]}
  \ifthenelse{\equal{\response}{m}}{\myctr=1}{
  \ifthenelse{\equal{\response}{f}}{\myctr=2}{%
  \ifthenelse{\equal{\response}{}}{\myctr=1}{%
  \myctr=-1
  \typeout{Invalid response '\response'}}}}
\fi
\ifnum\myctr=-1
\repeat
}
\fi

\ifcase\myctr
\or \def\gender{m}
\or \def\gender{f}
\or \def\gender{n}
\fi

\ifnum\langid=7
\ifnum\startval>99
\myctr=-1
\loop
\typeout{einhundert/eintausend or hundert/tausend?^^J}
\typeout{[1] einhundert/eintausend}
\typeout{[2] hundert/tausend}
\typein[\response]{Default: 1}
\ifthenelse{\equal{\response}{}}{\def\response{1}}{}%default
\ifthenelse{\equal{\response}{1}}{%
\renewcommand{\einhundert}{einhundert}
\renewcommand{\eintausend}{eintausend}
\myctr=1}{%
\ifthenelse{\equal{\response}{2}}{%
\renewcommand{\einhundert}{hundert}
\renewcommand{\eintausend}{tausend}
\myctr=2}{%
\myctr=-1}}
\ifnum\myctr=-1
\repeat
\fi
\fi

\setcounter{startval}{\startval}
\setcounter{endval}{\endval}
\setcounter{stepsize}{\stepsize}

\stepcounter{endval}
\begin{ttfamily}
\noindent 
\makebox[0.25in][c]{N}
\makebox[0.5in][c]{ordinal}\quad
\stringtype
\par
\myctr=\value{startval}
\loop
\noindent 
\setcounter{N}{\myctr}
\makebox[0.25in][r]{\arabic{N}}
\makebox[0.5in][r]{\ordinal{N}[\gender]}\quad
\csname\stringtype\endcsname{N}[\gender].
\par
\advance\myctr by \value{stepsize}\relax
\ifnum\myctr<\value{endval}
\repeat

\end{ttfamily}

\end{document}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-lang.tex>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-samp.tex>
%    \end{macrocode}
%\fi
%    \begin{macrocode}
\documentclass[a4paper]{article}

\usepackage{fmtcount}
\newcounter{N}

\padzeroes[5]

\newcommand{\printrow}[1]{%
\newline
\setcounter{N}{#1}
\makebox[0.75in][r]{\decimal{N}\quad}
\makebox[0.75in][r]{\hexadecimal{N}\quad}
\makebox[0.75in][r]{\ordinal{N}\quad}
\makebox[2in][l]{\numberstring{N}}
}

\renewcommand{\thesection}{\ordinal{section}}

\begin{document}

\section{Displaying the value of a counter}
\label{ex} 

\begin{ttfamily}
\noindent 
\makebox[0.75in][c]{decimal}
\makebox[0.75in][c]{hexadecimal}
\makebox[0.75in][c]{ordinal}
numberstring
\printrow{0}
\printrow{1}
\printrow{2}
\printrow{3}
\printrow{4}
\printrow{5}
\printrow{6}
\printrow{7}
\printrow{8}
\printrow{9}
\printrow{10}
\printrow{11}
\printrow{12}
\printrow{13}
\printrow{14}
\printrow{15}
\printrow{16}
\printrow{17}
\printrow{18}
\printrow{19}
\printrow{20}
\printrow{21}
\printrow{22}
\printrow{23}
\printrow{24}
\printrow{25}
\printrow{30}
\printrow{40}
\printrow{50}
\printrow{60}
\printrow{70}
\printrow{71}
\printrow{75}
\printrow{80}
\printrow{81}
\printrow{85}
\printrow{90}
\printrow{91}
\printrow{95}
\printrow{100}
\printrow{101}
\printrow{110}
\printrow{125}
\printrow{150}
\printrow{170}
\printrow{180}
\printrow{190}
\printrow{200}
\printrow{250}
\printrow{300}
\printrow{400}
\printrow{500}
\printrow{600}
\printrow{700}
\printrow{800}
\printrow{900}
\printrow{1000}
\printrow{99999}
\end{ttfamily}

\section{Cross-Referencing}

Referencing a label: \ref{ex}.

Passing numbers explicitly: \ordinalnum{10},
\Numberstringnum{10}, \NUMBERstringnum{10}, \Ordinalstringnum{10},
\ORDINALstringnum{10}.

\end{document}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-samp.tex>
%    \end{macrocode}
%\fi
%\Finale
\endinput
